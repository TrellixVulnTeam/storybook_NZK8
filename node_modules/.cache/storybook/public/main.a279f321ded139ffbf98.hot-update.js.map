{"version":3,"file":"main.a279f321ded139ffbf98.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAsCA;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAjCA;AADA;AAAA;AAAA;AAAA;;AAqCA;AAAA;;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AAKA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAIA;;AAEA;AACA;AACA;AAEA;AAKA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAIA;;AAEA;AAAA;AACA;AAAA;AADA;;AAIA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAeA;AAEA;AACA;AACA;;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AAIA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAMA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;AACA;AACA;AAFA;AAKA;AAEA;AACA;AACA;;AACA","sources":["webpack://@zendeskgarden/react-components/./packages/pagination/src/elements/Pagination/Pagination.tsx"],"sourcesContent":["/**\r\n * Copyright Zendesk, Inc.\r\n *\r\n * Use of this source code is governed under the Apache License, Version 2.0\r\n * found at http://www.apache.org/licenses/LICENSE-2.0.\r\n */\r\n\r\nimport React, { useState, useContext, HTMLAttributes } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { ThemeContext } from 'styled-components';\r\nimport { usePagination } from '@zendeskgarden/container-pagination';\r\nimport { getControlledValue } from '@zendeskgarden/container-utilities';\r\n\r\nimport { StyledPagination, StyledPage, StyledGap, StyledNavigation } from '../../styled';\r\n\r\nconst PREVIOUS_KEY = 'previous';\r\nconst NEXT_KEY = 'next';\r\n\r\nexport type PAGE_TYPE = 'next' | 'page' | 'gap' | 'previous';\r\n\r\nexport interface IPaginationProps extends Omit<HTMLAttributes<HTMLUListElement>, 'onChange'> {\r\n  /**\r\n   * Sets the current page. Pages start at 1.\r\n   */\r\n  currentPage: number;\r\n  /**\r\n   * Defines the total number of pages\r\n   */\r\n  totalPages: number;\r\n  /**\r\n   * Sets the number of pages that appear between the current page and a gap indicator\r\n   */\r\n  pagePadding?: number;\r\n  /**\r\n   * Positions the leading and trailing gap indicator, based on\r\n   * the current and total pages\r\n   */\r\n  pageGap?: number;\r\n  /**\r\n   * Handles page change events\r\n   *\r\n   * @param {any} currentPage The current page\r\n   */\r\n  onChange?: (currentPage: number) => void;\r\n  /**\r\n   * Applies localized labels, test attributes, etc. to individual pages\r\n   *\r\n   * @param {string} pageType The type of the page accepting the props.\r\n   *  One of: \"previous\", \"gap\", \"page\", \"next\"\r\n   * @param {any} props Default page props to transform\r\n   */\r\n  transformPageProps?: (pageType: PAGE_TYPE, props: any) => any;\r\n}\r\n\r\nconst Pagination = React.forwardRef<HTMLUListElement, IPaginationProps>(\r\n  (\r\n    {\r\n      currentPage: controlledCurrentPage,\r\n      transformPageProps,\r\n      totalPages,\r\n      pagePadding,\r\n      pageGap,\r\n      onChange,\r\n      ...otherProps\r\n    },\r\n    ref\r\n  ) => {\r\n    const [focusedItem, setFocusedItem] = useState<number | string>();\r\n    const [internalCurrentPage, setCurrentPage] = useState(1);\r\n    const currentPage = getControlledValue(controlledCurrentPage, internalCurrentPage)!;\r\n    const theme = useContext(ThemeContext);\r\n\r\n    const { getContainerProps, getPageProps, getPreviousPageProps, getNextPageProps } =\r\n      usePagination<number | string | undefined>({\r\n        rtl: theme.rtl,\r\n        focusedItem,\r\n        selectedItem: currentPage,\r\n        onFocus: item => {\r\n          setFocusedItem(item);\r\n        },\r\n        onSelect: item => {\r\n          let updatedCurrentPage = item;\r\n          let updatedFocusedKey = focusedItem;\r\n\r\n          if (updatedCurrentPage === PREVIOUS_KEY && currentPage > 1) {\r\n            updatedCurrentPage = currentPage - 1;\r\n\r\n            // Must manually change focusedKey once PreviousPage is no longer visible\r\n            if (updatedCurrentPage === 1 && focusedItem === PREVIOUS_KEY) {\r\n              updatedFocusedKey = 1;\r\n            }\r\n          } else if (updatedCurrentPage === NEXT_KEY && currentPage < totalPages) {\r\n            updatedCurrentPage = currentPage + 1;\r\n\r\n            // Must manually change focusedKey once NextPage is no longer visible\r\n            if (updatedCurrentPage === totalPages && updatedFocusedKey === NEXT_KEY) {\r\n              updatedFocusedKey = totalPages;\r\n            }\r\n          }\r\n\r\n          if (onChange && updatedCurrentPage !== undefined) {\r\n            onChange(updatedCurrentPage as number);\r\n          }\r\n\r\n          setFocusedItem(updatedFocusedKey);\r\n          setCurrentPage(updatedCurrentPage as number);\r\n        }\r\n      });\r\n\r\n    const getTransformedProps = (pageType: PAGE_TYPE, props: any = {}) => {\r\n      if (transformPageProps) {\r\n        return transformPageProps(pageType, props);\r\n      }\r\n\r\n      return props;\r\n    };\r\n\r\n    const renderPreviousPage = (rtl: boolean) => {\r\n      const isFirstPageSelected = totalPages > 0 && currentPage === 1;\r\n      const focusRef = React.createRef();\r\n\r\n      return (\r\n        <StyledNavigation\r\n          {...getTransformedProps(\r\n            'previous',\r\n            // The PreviousPage element should be hidden when first page is selected\r\n            isFirstPageSelected\r\n              ? { hidden: true }\r\n              : getPreviousPageProps({\r\n                  role: null,\r\n                  key: PREVIOUS_KEY,\r\n                  isFocused: focusedItem === PREVIOUS_KEY,\r\n                  item: PREVIOUS_KEY,\r\n                  ref: focusRef,\r\n                  focusRef\r\n                })\r\n          )}\r\n        >\r\n          {rtl ? <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" focusable=\"false\" viewBox=\"0 0 16 16\">\r\n  <path fill=\"currentColor\" d=\"M5.61 3.312a.5.5 0 01.718-.69l.062.066 4 5a.5.5 0 01.054.542l-.054.082-4 5a.5.5 0 01-.83-.55l.05-.074L9.359 8l-3.75-4.688z\"/>\r\n</svg> : <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" focusable=\"false\" viewBox=\"0 0 16 16\">\r\n  <path fill=\"currentColor\" d=\"M10.39 12.688a.5.5 0 01-.718.69l-.062-.066-4-5a.5.5 0 01-.054-.542l.054-.082 4-5a.5.5 0 01.83.55l-.05.074L6.641 8l3.75 4.688z\"/>\r\n</svg>}\r\n        </StyledNavigation>\r\n      );\r\n    };\r\n\r\n    const renderNextPage = (rtl: boolean) => {\r\n      const isLastPageSelected = currentPage === totalPages;\r\n      const focusRef = React.createRef();\r\n\r\n      return (\r\n        <StyledNavigation\r\n          {...getTransformedProps(\r\n            'next',\r\n            // The NextPage element should be hidden when the last page is selected\r\n            isLastPageSelected\r\n              ? { hidden: true }\r\n              : getNextPageProps({\r\n                  role: null,\r\n                  item: NEXT_KEY,\r\n                  key: NEXT_KEY,\r\n                  isFocused: focusedItem === NEXT_KEY,\r\n                  ref: focusRef,\r\n                  focusRef\r\n                })\r\n          )}\r\n        >\r\n          {rtl ? <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" focusable=\"false\" viewBox=\"0 0 16 16\">\r\n  <path fill=\"currentColor\" d=\"M5.61 3.312a.5.5 0 01.718-.69l.062.066 4 5a.5.5 0 01.054.542l-.054.082-4 5a.5.5 0 01-.83-.55l.05-.074L9.359 8l-3.75-4.688z\"/>\r\n</svg> : <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" focusable=\"false\" viewBox=\"0 0 16 16\">\r\n  <path fill=\"currentColor\" d=\"M10.39 12.688a.5.5 0 01-.718.69l-.062-.066-4-5a.5.5 0 01-.054-.542l.054-.082 4-5a.5.5 0 01.83.55l-.05.074L6.641 8l3.75 4.688z\"/>\r\n</svg>}\r\n        </StyledNavigation>\r\n      );\r\n    };\r\n\r\n    const createGap = (pageIndex: number) => (\r\n      <StyledGap {...getTransformedProps('gap', { key: `gap-${pageIndex}` })}>â€¦</StyledGap>\r\n    );\r\n\r\n    const createPage = (pageIndex: number) => {\r\n      const focusRef = React.createRef();\r\n\r\n      return (\r\n        <StyledPage\r\n          {...getTransformedProps(\r\n            'page',\r\n            getPageProps({\r\n              role: null,\r\n              key: pageIndex,\r\n              item: pageIndex,\r\n              page: pageIndex,\r\n              title: pageIndex.toString(),\r\n              current: currentPage === pageIndex,\r\n              ref: focusRef,\r\n              focusRef\r\n            })\r\n          )}\r\n        >\r\n          {pageIndex}\r\n        </StyledPage>\r\n      );\r\n    };\r\n\r\n    /**\r\n     * Renders all Page and Gap Elements based on pagePadding prop\r\n     */\r\n    const renderPages = () => {\r\n      const pages = [];\r\n      const PADDING = pagePadding!;\r\n      const GAP = pageGap!;\r\n\r\n      for (let pageIndex = 1; pageIndex <= totalPages; pageIndex++) {\r\n        // Always display current, first, and last pages\r\n        if (pageIndex === currentPage || pageIndex < GAP || pageIndex > totalPages - GAP + 1) {\r\n          pages.push(createPage(pageIndex));\r\n          continue;\r\n        }\r\n\r\n        let minimum;\r\n        let maximum;\r\n\r\n        if (currentPage <= GAP + PADDING) {\r\n          minimum = GAP + 1;\r\n          maximum = minimum + PADDING * 2;\r\n        } else if (currentPage >= totalPages - GAP - PADDING) {\r\n          maximum = totalPages - GAP;\r\n          minimum = maximum - PADDING * 2;\r\n        } else {\r\n          minimum = currentPage - PADDING;\r\n          maximum = currentPage + PADDING;\r\n        }\r\n\r\n        // Display padded window of pages\r\n        if (\r\n          (pageIndex >= minimum && pageIndex <= currentPage) ||\r\n          (pageIndex >= currentPage && pageIndex <= maximum)\r\n        ) {\r\n          pages.push(createPage(pageIndex));\r\n          continue;\r\n        }\r\n\r\n        // Handle start gap\r\n        if (pageIndex === GAP) {\r\n          if (minimum > GAP + 1 && currentPage > GAP + PADDING + 1) {\r\n            pages.push(createGap(pageIndex));\r\n          } else {\r\n            pages.push(createPage(pageIndex));\r\n          }\r\n\r\n          continue;\r\n        }\r\n\r\n        // Handle end gap\r\n        if (pageIndex === totalPages - GAP + 1) {\r\n          if (maximum < totalPages - GAP && currentPage < totalPages - GAP - PADDING) {\r\n            pages.push(createGap(pageIndex));\r\n          } else {\r\n            pages.push(createPage(pageIndex));\r\n          }\r\n\r\n          continue;\r\n        }\r\n      }\r\n\r\n      return pages;\r\n    };\r\n\r\n    return (\r\n      <StyledPagination {...getContainerProps({ role: null, ...otherProps })} ref={ref}>\r\n        {renderPreviousPage(theme.rtl)}\r\n        {totalPages > 0 && renderPages()}\r\n        {renderNextPage(theme.rtl)}\r\n      </StyledPagination>\r\n    );\r\n  }\r\n);\r\n\r\nPagination.propTypes = {\r\n  currentPage: PropTypes.number.isRequired,\r\n  totalPages: PropTypes.number.isRequired,\r\n  pagePadding: PropTypes.number,\r\n  pageGap: PropTypes.number,\r\n  onChange: PropTypes.func,\r\n  transformPageProps: PropTypes.func\r\n};\r\n\r\nPagination.defaultProps = {\r\n  pagePadding: 2,\r\n  pageGap: 2\r\n};\r\n\r\nPagination.displayName = 'Pagination';\r\n\r\n/**\r\n * @extends HTMLAttributes<HTMLUListElement>\r\n */\r\nexport default Pagination as React.FC<IPaginationProps & React.RefAttributes<HTMLUListElement>>;\r\n"],"names":[],"sourceRoot":""}