/**
 * Copyright Zendesk, Inc.
 *
 * Use of this source code is governed under the Apache License, Version 2.0
 * found at http://www.apache.org/licenses/LICENSE-2.0.
 */

import React, { useState, useRef, useEffect } from 'react';
import { useUIDSeed } from 'react-uid';
import { composeEventHandlers, KEY_CODES } from '@zendeskgarden/container-utilities';
import PropTypes from 'prop-types';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

var _excluded$1 = ["tabIndex", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur", "onKeyDown"],
    _excluded2 = ["role", "onMouseEnter", "onMouseLeave"];
var useTooltip = function useTooltip(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$delayMillisecond = _ref.delayMilliseconds,
      delayMilliseconds = _ref$delayMillisecond === void 0 ? 500 : _ref$delayMillisecond,
      id = _ref.id,
      isVisible = _ref.isVisible;
  var _useState = useState(isVisible),
      visibility = _useState[0],
      setVisibility = _useState[1];
  var seed = useUIDSeed();
  var _useState2 = useState(id || seed("tooltip_" + '0.5.15')),
      _id = _useState2[0];
  var isMounted = useRef(false);
  var openTooltipTimeoutId = useRef();
  var closeTooltipTimeoutId = useRef();
  var openTooltip = function openTooltip(delayMs) {
    if (delayMs === void 0) {
      delayMs = delayMilliseconds;
    }
    clearTimeout(closeTooltipTimeoutId.current);
    var timerId = setTimeout(function () {
      if (isMounted.current) {
        setVisibility(true);
      }
    }, delayMs);
    openTooltipTimeoutId.current = Number(timerId);
  };
  var closeTooltip = function closeTooltip(delayMs) {
    if (delayMs === void 0) {
      delayMs = delayMilliseconds;
    }
    clearTimeout(openTooltipTimeoutId.current);
    var timerId = setTimeout(function () {
      if (isMounted.current) {
        setVisibility(false);
      }
    }, delayMs);
    closeTooltipTimeoutId.current = Number(timerId);
  };
  useEffect(function () {
    isMounted.current = true;
    return function () {
      isMounted.current = false;
    };
  }, []);
  useEffect(function () {
    return function () {
      clearTimeout(openTooltipTimeoutId.current);
      clearTimeout(closeTooltipTimeoutId.current);
    };
  }, [closeTooltipTimeoutId, openTooltipTimeoutId]);
  var getTriggerProps = function getTriggerProps(_temp2) {
    var _ref2 = _temp2 === void 0 ? {} : _temp2,
        _ref2$tabIndex = _ref2.tabIndex,
        tabIndex = _ref2$tabIndex === void 0 ? 0 : _ref2$tabIndex,
        onMouseEnter = _ref2.onMouseEnter,
        onMouseLeave = _ref2.onMouseLeave,
        onFocus = _ref2.onFocus,
        onBlur = _ref2.onBlur,
        onKeyDown = _ref2.onKeyDown,
        other = _objectWithoutPropertiesLoose(_ref2, _excluded$1);
    return _extends({
      tabIndex: tabIndex,
      onMouseEnter: composeEventHandlers(onMouseEnter, function () {
        return openTooltip();
      }),
      onMouseLeave: composeEventHandlers(onMouseLeave, function () {
        return closeTooltip();
      }),
      onFocus: composeEventHandlers(onFocus, function () {
        return openTooltip();
      }),
      onBlur: composeEventHandlers(onBlur, function () {
        return closeTooltip(0);
      }),
      onKeyDown: composeEventHandlers(onKeyDown, function (event) {
        if (event.keyCode === KEY_CODES.ESCAPE && visibility) {
          closeTooltip(0);
        }
      }),
      'aria-describedby': _id,
      'data-garden-container-id': 'containers.tooltip',
      'data-garden-container-version': '0.5.15'
    }, other);
  };
  var getTooltipProps = function getTooltipProps(_temp3) {
    var _ref3 = _temp3 === void 0 ? {} : _temp3,
        _ref3$role = _ref3.role,
        role = _ref3$role === void 0 ? 'tooltip' : _ref3$role,
        onMouseEnter = _ref3.onMouseEnter,
        onMouseLeave = _ref3.onMouseLeave,
        other = _objectWithoutPropertiesLoose(_ref3, _excluded2);
    return _extends({
      role: role,
      onMouseEnter: composeEventHandlers(onMouseEnter, function () {
        return openTooltip();
      }),
      onMouseLeave: composeEventHandlers(onMouseLeave, function () {
        return closeTooltip();
      }),
      'aria-hidden': !visibility,
      id: _id
    }, other);
  };
  return {
    isVisible: visibility,
    getTooltipProps: getTooltipProps,
    getTriggerProps: getTriggerProps,
    openTooltip: openTooltip,
    closeTooltip: closeTooltip
  };
};

var _excluded = ["children", "render"];
var TooltipContainer = function TooltipContainer(_ref) {
  var children = _ref.children,
      _ref$render = _ref.render,
      render = _ref$render === void 0 ? children : _ref$render,
      options = _objectWithoutPropertiesLoose(_ref, _excluded);
  return React.createElement(React.Fragment, null, render(useTooltip(options)));
};
TooltipContainer.propTypes = {
  children: PropTypes.func,
  render: PropTypes.func,
  delayMilliseconds: PropTypes.number,
  isVisible: PropTypes.bool
};

export { TooltipContainer, useTooltip };
