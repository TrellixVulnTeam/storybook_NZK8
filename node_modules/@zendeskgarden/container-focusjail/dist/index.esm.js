/**
 * Copyright Zendesk, Inc.
 *
 * Use of this source code is governed under the Apache License, Version 2.0
 * found at http://www.apache.org/licenses/LICENSE-2.0.
 */

import React, { createRef, useRef, useState, useEffect, useCallback } from 'react';
import { composeEventHandlers, KEY_CODES } from '@zendeskgarden/container-utilities';
import { tabbable } from 'tabbable';
import PropTypes from 'prop-types';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

function ownerDocument(node) {
  return node && node.ownerDocument || document;
}

function activeElement(doc) {
  if (doc === void 0) {
    doc = ownerDocument();
  }
  try {
    var active = doc.activeElement;
    if (!active || !active.nodeName) return null;
    return active;
  } catch (e) {
    return doc.body;
  }
}

var _excluded$1 = ["onKeyDown"];
var useFocusJail = function useFocusJail(_temp) {
  var _ref = _temp === void 0 ? {
    containerRef: createRef()
  } : _temp,
      _ref$focusOnMount = _ref.focusOnMount,
      focusOnMount = _ref$focusOnMount === void 0 ? true : _ref$focusOnMount,
      _ref$restoreFocus = _ref.restoreFocus,
      restoreFocus = _ref$restoreFocus === void 0 ? true : _ref$restoreFocus,
      environment = _ref.environment,
      focusElem = _ref.focusElem,
      containerRef = _ref.containerRef;
  var restoreFocusElement = useRef(null);
  var _useState = useState(containerRef.current),
      currentRef = _useState[0],
      setCurrentRef = _useState[1];
  useEffect(function () {
    if (containerRef.current !== currentRef) {
      setCurrentRef(containerRef.current);
    }
  });
  var focusElement = useCallback(function (element) {
    if (focusElem) {
      focusElem(element);
    } else {
      element && element.focus();
    }
  }, [focusElem]);
  var validateContainerRef = function validateContainerRef() {
    if (!currentRef) {
      throw new Error('Accessibility Error: You must apply the ref prop to your containing element.');
    }
  };
  var getInitialFocusNode = function getInitialFocusNode() {
    var doc = environment ? environment : document;
    var activeElem = activeElement(doc);
    var containerElem = currentRef;
    return containerElem.contains(activeElem) ? activeElem : containerElem;
  };
  var getTabbableNodes = function getTabbableNodes() {
    var elements = tabbable(currentRef);
    return {
      firstItem: elements[0] || getInitialFocusNode(),
      lastItem: elements[elements.length - 1] || getInitialFocusNode()
    };
  };
  var getContainerProps = function getContainerProps(_temp2) {
    var _ref2 = _temp2 === void 0 ? {} : _temp2,
        onKeyDown = _ref2.onKeyDown,
        other = _objectWithoutPropertiesLoose(_ref2, _excluded$1);
    return _extends({
      onKeyDown: composeEventHandlers(onKeyDown, function (event) {
        if (event.keyCode !== KEY_CODES.TAB) {
          return;
        }
        validateContainerRef();
        var tabbableNodes = getTabbableNodes();
        if (event.shiftKey && (event.target === tabbableNodes.firstItem || event.target === currentRef)) {
          focusElement(tabbableNodes.lastItem);
          event.preventDefault();
        }
        if (!event.shiftKey && event.target === tabbableNodes.lastItem) {
          focusElement(tabbableNodes.firstItem);
          event.preventDefault();
        }
      }),
      'data-garden-container-id': 'containers.focusjail',
      'data-garden-container-version': '1.4.12'
    }, other);
  };
  useEffect(function () {
    restoreFocusElement.current = activeElement(environment || document);
    if (focusOnMount) {
      focusElement(currentRef);
    }
    return function () {
      var isBodyInactive = restoreFocusElement.current !== document.body;
      var hasActiveElement = restoreFocusElement.current !== null;
      if (isBodyInactive && hasActiveElement && restoreFocus) {
        focusElement(restoreFocusElement.current);
      }
    };
  }, [focusOnMount, restoreFocus, environment, focusElement, currentRef]);
  return {
    getContainerProps: getContainerProps,
    focusElement: focusElement
  };
};

var _excluded = ["children", "render"];
var FocusJailContainer = function FocusJailContainer(_ref) {
  var children = _ref.children,
      _ref$render = _ref.render,
      render = _ref$render === void 0 ? children : _ref$render,
      options = _objectWithoutPropertiesLoose(_ref, _excluded);
  return React.createElement(React.Fragment, null, render(useFocusJail(options)));
};
FocusJailContainer.propTypes = {
  children: PropTypes.func,
  render: PropTypes.func,
  focusOnMount: PropTypes.bool,
  environment: PropTypes.any,
  containerRef: PropTypes.any.isRequired,
  focusElem: PropTypes.func
};

export { FocusJailContainer, useFocusJail };
