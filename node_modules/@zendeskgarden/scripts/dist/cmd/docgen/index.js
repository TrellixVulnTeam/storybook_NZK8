"use strict";
/**
 * Copyright Zendesk, Inc.
 *
 * Use of this source code is governed under the Apache License, Version 2.0
 * found at http://www.apache.org/licenses/LICENSE-2.0.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = void 0;
const react_docgen_typescript_1 = require("react-docgen-typescript");
const commander_1 = require("commander");
const typescript_1 = require("typescript");
const globby_1 = __importDefault(require("globby"));
const utils_1 = require("../../utils");
const comment_parser_1 = require("comment-parser");
const path_1 = require("path");
const DEFAULT_EXTENSIONS = ['js', 'jsx', 'ts', 'tsx'];
const DEFAULT_IGNORE = ['**/*.spec.*', '**/dist/**', '**/node_modules/**'];
/**
 * Execute the `cmd-docgen` command.
 *
 * @param {string[] | string} args.paths Component path globs.
 * @param {string[]} [args.extensions] File extensions to consider.
 * @param {string[]} [args.ignore] Paths to ignore.
 * @param {Ora} [args.spinner] Terminal spinner.
 *
 * @returns {object} Generated component documentation information.
 */
const execute = async (args = {
    paths: [],
    extensions: DEFAULT_EXTENSIONS,
    ignore: DEFAULT_IGNORE
}) => {
    let retVal;
    try {
        const parserOptions = {
            propFilter: props => !(props.description.includes('@ignore') ||
                (props.parent && props.parent.fileName.includes('node_modules'))),
            shouldRemoveUndefinedFromOptional: true
        };
        const globbyOptions = {
            expandDirectories: {
                extensions: args.extensions || DEFAULT_EXTENSIONS
            },
            ignore: args.ignore || DEFAULT_IGNORE
        };
        for await (const path of Array.isArray(args.paths) ? args.paths : [args.paths]) {
            const resolvedPath = (0, path_1.resolve)(path);
            /* eslint-disable-next-line @typescript-eslint/unbound-method */
            const tsconfigPath = (0, typescript_1.findConfigFile)(resolvedPath, typescript_1.sys.fileExists);
            const parser = tsconfigPath
                ? (0, react_docgen_typescript_1.withCustomConfig)(tsconfigPath, parserOptions)
                : (0, react_docgen_typescript_1.withDefaultConfig)(parserOptions);
            const paths = await (0, globby_1.default)(resolvedPath, globbyOptions);
            const components = parser.parse(paths);
            retVal = components.map(component => {
                const props = {};
                Object.keys(component.props)
                    .sort(undefined)
                    .forEach(key => {
                    const prop = component.props[key];
                    const type = prop.type.name.replace(/"/gu, "'");
                    let defaultValue = prop.defaultValue && prop.defaultValue.value && prop.defaultValue.value.toString();
                    if ((type === 'string' && defaultValue !== null) ||
                        type.includes(`'${defaultValue}'`)) {
                        // Surround default string literals with quotes.
                        defaultValue = `'${defaultValue}'`;
                    }
                    const params = {};
                    let description;
                    let returns;
                    if (prop.description) {
                        description = (0, comment_parser_1.parse)(`/** ${prop.description} */`)[0];
                        description.tags
                            .filter(tag => tag.tag === 'param')
                            .forEach(param => {
                            params[param.name] = param.description;
                        });
                        returns = description.tags.find(tag => tag.tag.startsWith('return'));
                    }
                    props[key] = {
                        description: description ? description.description : '',
                        defaultValue,
                        required: prop.required,
                        type,
                        params,
                        returns: returns ? returns.description : undefined
                    };
                });
                return {
                    name: component.displayName,
                    description: component.description,
                    extends: component.tags ? component.tags.extends : '',
                    props,
                    file: component.filePath
                };
            });
        }
    }
    catch (error) {
        (0, utils_1.handleErrorMessage)(error, 'cmd-docgen', args.spinner);
        throw error;
    }
    return retVal;
};
exports.execute = execute;
exports.default = (spinner) => {
    const command = new commander_1.Command('cmd-docgen');
    return command
        .description('generate component documentation')
        .argument('<paths...>', 'one or more component paths')
        .option('-x --extensions <extensions...>', 'file extensions to consider', DEFAULT_EXTENSIONS)
        .option('-i --ignore <ignore...>', 'paths to ignore', DEFAULT_IGNORE)
        .option('--pretty', 'pretty-print JSON')
        .action(async (paths) => {
        try {
            spinner.start();
            const options = command.opts();
            const result = await (0, exports.execute)({
                paths,
                extensions: options.extensions,
                ignore: options.ignore,
                spinner
            });
            if (result) {
                if (result.length > 0) {
                    const space = options.pretty ? 2 : undefined;
                    const message = JSON.stringify(result, undefined, space);
                    (0, utils_1.handleSuccessMessage)(message, spinner);
                }
                else {
                    (0, utils_1.handleWarningMessage)('Component not found', spinner);
                }
            }
            else {
                throw Error();
            }
        }
        catch {
            spinner.fail('Unable to generate documentation');
            process.exitCode = 1;
        }
        finally {
            spinner.stop();
        }
    });
};
