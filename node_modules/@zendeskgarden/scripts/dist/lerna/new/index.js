"use strict";
/**
 * Copyright Zendesk, Inc.
 *
 * Use of this source code is governed under the Apache License, Version 2.0
 * found at http://www.apache.org/licenses/LICENSE-2.0.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = void 0;
const commander_1 = require("commander");
const utils_1 = require("../../utils");
const lodash_1 = require("lodash");
const pluralize_1 = require("pluralize");
const promises_1 = require("fs/promises");
const fs_extra_1 = require("fs-extra");
const handlebars_1 = __importDefault(require("handlebars"));
const handlebars_helpers_1 = __importDefault(require("handlebars-helpers"));
const path_1 = require("path");
const klaw_1 = __importDefault(require("klaw"));
/**
 * Register handlebars helpers.
 */
const registerHelpers = () => {
    (0, handlebars_helpers_1.default)({ handlebars: handlebars_1.default });
    handlebars_1.default.registerHelper('kebabcase', (string) => (0, lodash_1.kebabCase)(string));
    handlebars_1.default.registerHelper('pluralize', (string) => (0, pluralize_1.plural)(string));
    handlebars_1.default.registerHelper('singularize', (string) => (0, pluralize_1.singular)(string));
    handlebars_1.default.registerHelper('snakecase', (string) => (0, lodash_1.snakeCase)(string));
    handlebars_1.default.registerHelper('startcase', (string) => (0, lodash_1.startCase)(string));
};
/**
 * Execute the `lerna-new` command.
 *
 * @param {string} args.src Source directory.
 * @param {string} args.dest Destination directory.
 * @param {object} args.tags Handlebars template name-value pairs.
 * @param {string} [args.spinner] Terminal spinner.
 *
 * @returns {object} The resolved source and destination paths.
 */
const execute = async (args) => {
    const retVal = {
        src: (0, path_1.resolve)(args.src),
        dest: (0, path_1.resolve)(args.dest)
    };
    try {
        await (0, fs_extra_1.copy)(retVal.src, retVal.dest, { overwrite: false, errorOnExist: true });
        registerHelpers();
        for await (const file of (0, klaw_1.default)(retVal.dest)) {
            const path = handlebars_1.default.compile(file.path)(args.tags);
            if (file.path !== path) {
                await (0, promises_1.rename)(file.path, path);
            }
            if (!file.stats.isDirectory()) {
                const content = await (0, promises_1.readFile)(path, 'utf8');
                const data = handlebars_1.default.compile(content)(args.tags);
                await (0, promises_1.writeFile)(path, data, 'utf8');
            }
        }
    }
    catch (error) {
        (0, utils_1.handleErrorMessage)(error, 'lerna-new', args.spinner);
        throw error;
    }
    return retVal;
};
exports.execute = execute;
exports.default = (spinner) => {
    const command = new commander_1.Command('lerna-new');
    return command
        .description('generate a new package from a template source directory')
        .argument('<src>', 'template source directory')
        .argument('<dest>', 'package destination directory')
        .option('-t --tag <tags...>', '{{Handlebars}} template <name>=<value> tags', (tag, retVal = {}) => {
        const [name, value] = tag.split('=');
        retVal[name] = value;
        return retVal;
    })
        .action(async (src, dest) => {
        try {
            spinner.start();
            const tags = command.opts().tag;
            const result = await (0, exports.execute)({ src, dest, tags, spinner });
            if (result) {
                (0, utils_1.handleSuccessMessage)(`${result.src} -> ${result.dest}`, spinner);
            }
            else {
                throw new Error();
            }
        }
        catch {
            spinner.fail('Unable to generate new package');
            process.exitCode = 1;
        }
        finally {
            spinner.stop();
        }
    });
};
