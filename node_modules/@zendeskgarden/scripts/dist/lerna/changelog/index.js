"use strict";
/**
 * Copyright Zendesk, Inc.
 *
 * Use of this source code is governed under the Apache License, Version 2.0
 * found at http://www.apache.org/licenses/LICENSE-2.0.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = void 0;
const commander_1 = require("commander");
const utils_1 = require("../../utils");
const lerna_changelog_1 = require("lerna-changelog");
const execa_1 = __importDefault(require("execa"));
const configuration_1 = require("lerna-changelog/lib/configuration");
const github_1 = require("../../github");
/**
 * Execute the `lerna-changelog` command.
 *
 * @param {string} [args.from] GitHub ref (commit SHA, tag).
 * @param {string} [args.to] GitHub ref (commit SHA, tag).
 * @param {string} [args.path] Path to a git directory.
 * @param {string} [args.token] GitHub personal access token.
 * @param {Ora} [args.spinner] Terminal spinner.
 *
 * @returns {Promise<string>} The markdown result of the changelog command.
 */
const execute = async (args = {}) => {
    let retVal;
    try {
        process.env.GITHUB_AUTH = args.token || (await (0, github_1.token)(args.spinner));
        const revParseArgs = ['rev-parse', '--show-toplevel'];
        const describeArgs = ['describe', '--abbrev=0', '--tags'];
        if (args.path) {
            revParseArgs.unshift('-C', args.path);
            describeArgs.unshift('-C', args.path);
        }
        const rootPath = await (0, execa_1.default)('git', revParseArgs);
        const config = (0, configuration_1.fromPath)(rootPath.stdout);
        const changelog = new lerna_changelog_1.Changelog(config);
        let tagTo = args.to;
        let tagFrom = args.from;
        if (!tagTo) {
            const describe = await (0, execa_1.default)('git', describeArgs);
            tagTo = describe.stdout.toString();
        }
        if (!tagFrom) {
            describeArgs.push(`${tagTo}^`);
            const describe = await (0, execa_1.default)('git', describeArgs);
            tagFrom = describe.stdout.toString();
        }
        process.chdir(rootPath.stdout);
        retVal = await changelog.createMarkdown({
            tagFrom,
            tagTo
        });
    }
    catch (error /* eslint-disable-line @typescript-eslint/no-implicit-any-catch */) {
        (0, utils_1.handleErrorMessage)(error.message ? error.message : error, 'lerna-changelog', args.spinner);
        throw error;
    }
    return retVal;
};
exports.execute = execute;
exports.default = (spinner) => {
    const command = new commander_1.Command('lerna-changelog');
    return command
        .description('output generated changelog markdown for the repo')
        .arguments('[path]')
        .option('-f, --from <from-tag>', 'GitHub tag or commit SHA')
        .option('-t, --to <to-tag>', 'GitHub tag or commit SHA')
        .option('-a, --token <token>', 'GitHub access token')
        .action(async (path) => {
        try {
            spinner.start();
            const options = command.opts();
            const markdown = await (0, exports.execute)({
                path,
                from: options.from,
                to: options.to,
                token: options.token,
                spinner
            });
            if (markdown) {
                (0, utils_1.handleSuccessMessage)(markdown, spinner);
            }
            else {
                throw new Error();
            }
        }
        catch {
            spinner.fail('Unable to generate changelog');
            process.exitCode = 1;
        }
        finally {
            spinner.stop();
        }
    });
};
