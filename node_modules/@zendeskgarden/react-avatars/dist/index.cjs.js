/**
 * Copyright Zendesk, Inc.
 *
 * Use of this source code is governed under the Apache License, Version 2.0
 * found at http://www.apache.org/licenses/LICENSE-2.0.
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var PropTypes = require('prop-types');
var styled = require('styled-components');
var polished = require('polished');
var reactTheming = require('@zendeskgarden/react-theming');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var PropTypes__default = /*#__PURE__*/_interopDefaultLegacy(PropTypes);
var styled__default = /*#__PURE__*/_interopDefaultLegacy(styled);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var COMPONENT_ID$1 = 'avatars.text';
var StyledText = styled__default['default'].span.attrs({
  'data-garden-id': COMPONENT_ID$1,
  'data-garden-version': '8.47.1'
}).withConfig({
  displayName: "StyledText",
  componentId: "sc-1a6hivh-0"
})(["overflow:hidden;text-align:center;white-space:nowrap;", ";"], function (props) {
  return reactTheming.retrieveComponentStyles(COMPONENT_ID$1, props);
});
StyledText.defaultProps = {
  theme: reactTheming.DEFAULT_THEME
};

var COMPONENT_ID = 'avatars.avatar';
var TRANSITION_DURATION = 0.25;
var badgeStyles = function badgeStyles(props) {
  var content = "''";
  var position = '0';
  var padding = '0';
  var minWidth = '0';
  var height = '0';
  var fontSize = '0';
  var borderWidth = props.theme.shadowWidths.sm;
  if (props.status === 'active') {
    position = "".concat(props.theme.space.base * -1, "px");
    if (props.size === 'small') {
      fontSize = props.theme.fontSizes.xs;
      height = "".concat(props.theme.space.base * 4, "px");
      minWidth = fontSize;
      padding = "".concat(props.theme.space.base - 1, "px");
      content = 'attr(data-badge)';
    } else if (props.size === 'extrasmall') {
      height = "".concat(props.theme.space.base * 2, "px");
      minWidth = height;
    } else if (props.size === 'extraextrasmall') {
      position = polished.math("".concat(position, " + 1"));
      height = "".concat(props.theme.space.base + 1, "px");
      minWidth = height;
      borderWidth = polished.math("".concat(borderWidth, " - 1"));
    } else {
      fontSize = props.theme.fontSizes.xs;
      height = "".concat(props.theme.space.base * 5, "px");
      minWidth = fontSize;
      padding = "".concat(props.theme.space.base + 1, "px");
      content = 'attr(data-badge)';
    }
  } else if (props.status === 'available') {
    position = "".concat(props.theme.space.base * -1, "px");
    if (props.size === 'large') {
      height = "".concat(props.theme.space.base * 3.5, "px");
    } else if (props.size === 'small') {
      height = "".concat(props.theme.space.base * 2.5, "px");
    } else if (props.size === 'extrasmall') {
      height = "".concat(props.theme.space.base * 2, "px");
    } else if (props.size === 'extraextrasmall') {
      position = polished.math("".concat(position, " + 1"));
      height = "".concat(props.theme.space.base + 1, "px");
      borderWidth = polished.math("".concat(borderWidth, " - 1"));
    } else {
      height = "".concat(props.theme.space.base * 3, "px");
    }
    minWidth = height;
  } else if (props.size === 'large') {
    position = polished.math("".concat(props.theme.shadowWidths.sm, " + 1"));
  } else if (props.size === 'small') {
    position = polished.math("".concat(props.theme.shadowWidths.sm, " - 1"));
  } else if (props.size === 'medium') {
    position = props.theme.shadowWidths.sm;
  }
  var animation = styled.keyframes(["0%{transform:scale(.1);}"]);
  var opacity = props.status === 'active' || props.status === 'available' ? 1 : 0;
  var border = "".concat(borderWidth, " ").concat(props.theme.borderStyles.solid);
  return styled.css(["display:inline-block;position:absolute;", ":", ";bottom:", ";transition:all ", "s ease-in-out,color 0s;opacity:", ";border:", ";border-radius:100px;padding:0 ", ";min-width:", ";max-width:2em;height:", ";box-sizing:content-box !important;overflow:hidden;text-align:center;text-overflow:ellipsis;line-height:", ";white-space:nowrap;font-size:", ";font-weight:", ";content:", ";", ""], props.theme.rtl ? 'left' : 'right', position, position, TRANSITION_DURATION, opacity, border, padding, minWidth, height, height === '0' ? '1px' : height, fontSize, props.theme.fontWeights.semibold, content, props.status === 'active' && styled.css(["animation:", " ", "s ease-in-out;"], animation, TRANSITION_DURATION * 1.5));
};
var colorStyles = function colorStyles(props) {
  var statusColor = 'transparent';
  var backgroundColor = props.backgroundColor || 'transparent';
  var foregroundColor = props.foregroundColor || props.theme.palette.white;
  var surfaceColor = props.status ? props.surfaceColor || props.theme.colors.background : 'transparent';
  if (props.status === 'available') {
    statusColor = reactTheming.getColor('mint', 400, props.theme);
  } else if (props.status === 'active') {
    statusColor = reactTheming.getColor('crimson', 400, props.theme);
  } else if (props.status === 'away') {
    statusColor = reactTheming.getColor('yellow', 400, props.theme);
  }
  return styled.css(["box-shadow:", ";background-color:", ";color:", ";& > svg,& ", "{color:", ";}&::after{background-color:", ";-webkit-text-fill-color:", ";}_:-ms-input-placeholder,&::after{color:", ";}"], props.theme.shadows.sm(statusColor), backgroundColor, surfaceColor, StyledText, foregroundColor, statusColor, props.theme.palette.white, props.theme.palette.white);
};
var sizeStyles = function sizeStyles(props) {
  var boxShadow;
  var borderRadius;
  var size;
  var fontSize;
  var svgSize;
  if (props.size === 'extraextrasmall') {
    boxShadow = "0 0 0 ".concat(polished.math("".concat(props.theme.shadowWidths.sm, " - 1")));
    borderRadius = props.isSystem ? polished.math("".concat(props.theme.borderRadii.md, " - 1")) : '50%';
    size = "".concat(props.theme.space.base * 4, "px");
    fontSize = 0;
    svgSize = "".concat(props.theme.space.base * 3, "px");
  } else if (props.size === 'extrasmall') {
    boxShadow = "inset 0 0 0 ".concat(props.theme.shadowWidths.sm);
    borderRadius = props.isSystem ? polished.math("".concat(props.theme.borderRadii.md, " - 1")) : '50%';
    size = "".concat(props.theme.space.base * 6, "px");
    fontSize = props.theme.fontSizes.sm;
    svgSize = "".concat(props.theme.space.base * 3, "px");
  } else if (props.size === 'small') {
    boxShadow = "inset 0 0 0 ".concat(props.theme.shadowWidths.sm);
    borderRadius = props.isSystem ? polished.math("".concat(props.theme.borderRadii.md, " - 1")) : '50%';
    size = "".concat(props.theme.space.base * 8, "px");
    fontSize = props.theme.fontSizes.md;
    svgSize = "".concat(props.theme.space.base * 3, "px");
  } else if (props.size === 'large') {
    boxShadow = "inset 0 0 0 ".concat(props.theme.shadowWidths.sm);
    borderRadius = props.isSystem ? polished.math("".concat(props.theme.borderRadii.md, " + 1")) : '50%';
    size = "".concat(props.theme.space.base * 12, "px");
    fontSize = props.theme.fontSizes.xl;
    svgSize = "".concat(props.theme.space.base * 6, "px");
  } else {
    boxShadow = "inset 0 0 0 ".concat(props.theme.shadowWidths.sm);
    borderRadius = props.isSystem ? props.theme.borderRadii.md : '50%';
    size = "".concat(props.theme.space.base * 10, "px");
    fontSize = props.theme.fontSizes.lg;
    svgSize = "".concat(props.theme.space.base * 4, "px");
  }
  return styled.css(["border-radius:", ";width:", " !important;height:", " !important;::before{box-shadow:", ";}& > svg{font-size:", ";}& ", "{line-height:", ";font-size:", ";}"], borderRadius, size, size, boxShadow, svgSize, StyledText, size, fontSize);
};
var StyledAvatar = styled__default['default'].figure.attrs({
  'data-garden-id': COMPONENT_ID,
  'data-garden-version': '8.47.1'
}).withConfig({
  displayName: "StyledAvatar",
  componentId: "sc-608m04-0"
})(["display:inline-flex;position:relative;align-items:center;justify-content:center;transition:box-shadow ", "s ease-in-out,color 0.1s ease-in-out;margin:0;vertical-align:middle;box-sizing:border-box;", ";", ";&::before{position:absolute;top:0;left:0;transition:box-shadow ", "s ease-in-out;content:'';}&::before,&& > img{border-radius:inherit;width:100%;height:100%;}&& > img{box-sizing:inherit;vertical-align:bottom;object-fit:cover;}&& > svg{width:1em;height:1em;}&::after{", ";}", ";"], TRANSITION_DURATION, function (props) {
  return sizeStyles(props);
}, function (props) {
  return colorStyles(props);
}, TRANSITION_DURATION, function (props) {
  return badgeStyles(props);
}, function (props) {
  return reactTheming.retrieveComponentStyles(COMPONENT_ID, props);
});
StyledAvatar.defaultProps = {
  size: 'medium',
  theme: reactTheming.DEFAULT_THEME
};

var _excluded = ["isSystem", "size", "status", "children", "badge", "surfaceColor", "backgroundColor", "foregroundColor"];
var Avatar = React__default['default'].forwardRef(function (_ref, ref) {
  var isSystem = _ref.isSystem,
      size = _ref.size,
      status = _ref.status,
      children = _ref.children,
      badge = _ref.badge,
      surfaceColor = _ref.surfaceColor,
      backgroundColor = _ref.backgroundColor,
      foregroundColor = _ref.foregroundColor,
      other = _objectWithoutProperties(_ref, _excluded);
  var computedStatus = badge === undefined ? status : 'active';
  return React__default['default'].createElement(StyledAvatar, _extends({
    ref: ref,
    isSystem: isSystem,
    size: size,
    status: computedStatus,
    "data-badge": badge,
    surfaceColor: surfaceColor,
    backgroundColor: backgroundColor,
    foregroundColor: foregroundColor,
    "aria-atomic": "true",
    "aria-live": "polite"
  }, other), React.Children.only(children));
});
Avatar.displayName = 'Avatar';
Avatar.propTypes = {
  backgroundColor: PropTypes__default['default'].string,
  foregroundColor: PropTypes__default['default'].string,
  surfaceColor: PropTypes__default['default'].string,
  isSystem: PropTypes__default['default'].bool,
  badge: PropTypes__default['default'].oneOfType([PropTypes__default['default'].string, PropTypes__default['default'].number]),
  size: PropTypes__default['default'].oneOf(['extraextrasmall', 'extrasmall', 'small', 'medium', 'large']),
  status: PropTypes__default['default'].oneOf(['available', 'away'])
};
Avatar.defaultProps = {
  size: 'medium'
};
Avatar.Text = StyledText;

exports.Avatar = Avatar;
