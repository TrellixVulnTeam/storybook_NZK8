/**
 * Copyright Zendesk, Inc.
 *
 * Use of this source code is governed under the Apache License, Version 2.0
 * found at http://www.apache.org/licenses/LICENSE-2.0.
 */

import * as React from 'react';
import React__default, { createContext, useContext, useCallback, useReducer, useRef, useEffect, useState, useMemo } from 'react';
import PropTypes from 'prop-types';
import styled, { css, ThemeContext } from 'styled-components';
import { Manager, Reference, Popper } from 'react-popper';
import { composeEventHandlers, KEY_CODES } from '@zendeskgarden/container-utilities';
import { retrieveComponentStyles, DEFAULT_THEME, menuStyles, getColor } from '@zendeskgarden/react-theming';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends$2() {
  _extends$2 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$2.apply(this, arguments);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function getPopperPlacement(gardenPlacement) {
  switch (gardenPlacement) {
    case 'end':
      return 'right';
    case 'end-top':
      return 'right-start';
    case 'end-bottom':
      return 'right-end';
    case 'start':
      return 'left';
    case 'start-top':
      return 'left-start';
    case 'start-bottom':
      return 'left-end';
    default:
      return gardenPlacement;
  }
}
function getRtlPopperPlacement(gardenPlacement) {
  var popperPlacement = getPopperPlacement(gardenPlacement);
  switch (popperPlacement) {
    case 'left':
      return 'right';
    case 'left-start':
      return 'right-start';
    case 'left-end':
      return 'right-end';
    case 'top-start':
      return 'top-end';
    case 'top-end':
      return 'top-start';
    case 'right':
      return 'left';
    case 'right-start':
      return 'left-start';
    case 'right-end':
      return 'left-end';
    case 'bottom-start':
      return 'bottom-end';
    case 'bottom-end':
      return 'bottom-start';
    default:
      return popperPlacement;
  }
}
function getMenuPosition(popperPlacement) {
  return popperPlacement ? popperPlacement.split('-')[0] : 'bottom';
}

function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
  }
}

function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === 'object' && argStr === '[object Date]') {
    return new Date(argument.getTime());
  } else if (typeof argument === 'number' || argStr === '[object Number]') {
    return new Date(argument);
  } else {
    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule");
      console.warn(new Error().stack);
    }
    return new Date(NaN);
  }
}

function startOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
  return date;
}

function endOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = date.getMonth();
  date.setFullYear(date.getFullYear(), month + 1, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}

function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

function startOfWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }
  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setDate(date.getDate() - diff);
  date.setHours(0, 0, 0, 0);
  return date;
}

function endOfWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }
  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  date.setDate(date.getDate() + diff);
  date.setHours(23, 59, 59, 999);
  return date;
}

function eachDayOfInterval(dirtyInterval, options) {
  requiredArgs(1, arguments);
  var interval = dirtyInterval || {};
  var startDate = toDate(interval.start);
  var endDate = toDate(interval.end);
  var endTime = endDate.getTime();
  if (!(startDate.getTime() <= endTime)) {
    throw new RangeError('Invalid interval');
  }
  var dates = [];
  var currentDate = startDate;
  currentDate.setHours(0, 0, 0, 0);
  var step = options && 'step' in options ? Number(options.step) : 1;
  if (step < 1 || isNaN(step)) throw new RangeError('`options.step` must be a number greater than 1');
  while (currentDate.getTime() <= endTime) {
    dates.push(toDate(currentDate));
    currentDate.setDate(currentDate.getDate() + step);
    currentDate.setHours(0, 0, 0, 0);
  }
  return dates;
}

function addDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  date.setDate(date.getDate() + amount);
  return date;
}

function startOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}

function isSameDay(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfDay = startOfDay(dirtyDateLeft);
  var dateRightStartOfDay = startOfDay(dirtyDateRight);
  return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
}

function isToday(dirtyDate) {
  requiredArgs(1, arguments);
  return isSameDay(dirtyDate, Date.now());
}

function isSameMonth(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() === dateRight.getFullYear() && dateLeft.getMonth() === dateRight.getMonth();
}

function isBefore(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() < dateToCompare.getTime();
}

function isAfter(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() > dateToCompare.getTime();
}

function getDate(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var dayOfMonth = date.getDate();
  return dayOfMonth;
}

var COMPONENT_ID$b = 'datepickers.menu';
var StyledMenu = styled.div.attrs({
  'data-garden-id': COMPONENT_ID$b,
  'data-garden-version': '8.47.1'
}).withConfig({
  displayName: "StyledMenu",
  componentId: "sc-1npbkk0-0"
})(["", ";"], function (props) {
  return retrieveComponentStyles(COMPONENT_ID$b, props);
});
StyledMenu.defaultProps = {
  theme: DEFAULT_THEME
};

var COMPONENT_ID$a = 'datepickers.menu_wrapper';
var StyledMenuWrapper = styled.div.attrs(function (props) {
  return {
    className: props.isAnimated && 'is-animated'
  };
}).withConfig({
  displayName: "StyledMenuWrapper",
  componentId: "sc-6fowoz-0"
})(["", ";", ";"], function (props) {
  return menuStyles(getMenuPosition(props.placement), {
    theme: props.theme,
    hidden: props.isHidden,
    margin: "".concat(props.theme.space.base, "px"),
    zIndex: props.zIndex,
    animationModifier: props.isAnimated ? '.is-animated' : undefined
  });
}, function (props) {
  return retrieveComponentStyles(COMPONENT_ID$a, props);
});
StyledMenuWrapper.defaultProps = {
  theme: DEFAULT_THEME
};

var COMPONENT_ID$9 = 'datepickers.datepicker';
var retrievePadding = function retrievePadding(_ref) {
  var isCompact = _ref.isCompact,
      theme = _ref.theme;
  var value = theme.space.base * 5;
  if (isCompact) {
    value = theme.space.base * 4;
  }
  return "margin: ".concat(value, "px;");
};
var StyledDatepicker = styled.div.attrs({
  'data-garden-id': COMPONENT_ID$9
}).withConfig({
  displayName: "StyledDatepicker",
  componentId: "sc-w3zqsp-0"
})(["direction:", ";", " background-color:", ";color:", ";", ";"], function (props) {
  return props.theme.rtl && 'rtl';
}, retrievePadding, function (props) {
  return props.theme.colors.background;
}, function (props) {
  return props.theme.colors.foreground;
}, function (props) {
  return retrieveComponentStyles(COMPONENT_ID$9, props);
});
StyledDatepicker.defaultProps = {
  theme: DEFAULT_THEME
};

var COMPONENT_ID$8 = 'datepickers.range_calendar';
var StyledRangeCalendar = styled.div.attrs({
  'data-garden-id': COMPONENT_ID$8
}).withConfig({
  displayName: "StyledRangeCalendar",
  componentId: "sc-1og46sy-0"
})(["display:flex;overflow:auto;", "{margin:0;", "}", ";"], StyledDatepicker, function (props) {
  return props.theme.rtl ? "&:last-of-type {margin-right: ".concat(props.theme.space.base * 5, "px}") : "&:first-of-type {margin-right: ".concat(props.theme.space.base * 5, "px}");
}, function (props) {
  return retrieveComponentStyles(COMPONENT_ID$8, props);
});
StyledRangeCalendar.defaultProps = {
  theme: DEFAULT_THEME
};

var COMPONENT_ID$7 = 'datepickers.header';
var StyledHeader = styled.div.attrs({
  'data-garden-id': COMPONENT_ID$7
}).withConfig({
  displayName: "StyledHeader",
  componentId: "sc-upq318-0"
})(["display:flex;width:", "px;", ";"], function (props) {
  return props.isCompact ? props.theme.space.base * 56 : props.theme.space.base * 70;
}, function (props) {
  return retrieveComponentStyles(COMPONENT_ID$7, props);
});
StyledHeader.defaultProps = {
  theme: DEFAULT_THEME
};

var retrieveSizing = function retrieveSizing(_ref) {
  var isCompact = _ref.isCompact,
      theme = _ref.theme;
  var size = theme.space.base * 10;
  if (isCompact) {
    size = theme.space.base * 8;
  }
  return css(["width:", "px;height:", "px;"], size, size);
};
var retrieveColor$1 = function retrieveColor(_ref2) {
  var theme = _ref2.theme;
  return css([":hover{background-color:", ";color:", ";}:active{background-color:", ";color:", ";}color:", ";"], getColor('primaryHue', 600, theme, 0.08), theme.colors.foreground, getColor('primaryHue', 600, theme, 0.2), theme.colors.foreground, getColor('neutralHue', 600, theme));
};
var COMPONENT_ID$6 = 'datepickers.header_paddle';
var StyledHeaderPaddle = styled.div.attrs({
  'data-garden-id': COMPONENT_ID$6
}).withConfig({
  displayName: "StyledHeaderPaddle",
  componentId: "sc-2oqh0g-0"
})(["display:flex;align-items:center;justify-content:center;transform:", ";visibility:", ";border-radius:50%;cursor:pointer;", " ", " svg{width:", ";height:", ";}", ";"], function (props) {
  return props.theme.rtl && 'rotate(180deg)';
}, function (props) {
  return props.isHidden && 'hidden';
},
retrieveSizing, retrieveColor$1, function (props) {
  return "".concat(props.theme.iconSizes.md);
}, function (props) {
  return "".concat(props.theme.iconSizes.md);
}, function (props) {
  return retrieveComponentStyles(COMPONENT_ID$6, props);
});
StyledHeaderPaddle.defaultProps = {
  theme: DEFAULT_THEME
};

var COMPONENT_ID$5 = 'datepickers.header_label';
var StyledHeaderLabel = styled.div.attrs({
  'data-garden-id': COMPONENT_ID$5
}).withConfig({
  displayName: "StyledHeaderLabel",
  componentId: "sc-1ryf5ub-0"
})(["display:flex;flex-grow:1;align-items:center;justify-content:center;font-size:", ";font-weight:", ";", ";"], function (props) {
  return props.isCompact ? props.theme.fontSizes.sm : props.theme.fontSizes.md;
}, function (props) {
  return props.theme.fontWeights.semibold;
}, function (props) {
  return retrieveComponentStyles(COMPONENT_ID$5, props);
});
StyledHeaderLabel.defaultProps = {
  theme: DEFAULT_THEME
};

var COMPONENT_ID$4 = 'datepickers.calendar';
var StyledCalendar = styled.div.attrs({
  'data-garden-id': COMPONENT_ID$4
}).withConfig({
  displayName: "StyledCalendar",
  componentId: "sc-g5hoe8-0"
})(["width:", "px;", ";"], function (props) {
  return props.isCompact ? props.theme.space.base * 56 : props.theme.space.base * 70;
}, function (props) {
  return retrieveComponentStyles(COMPONENT_ID$4, props);
});
StyledCalendar.defaultProps = {
  theme: DEFAULT_THEME
};

var COMPONENT_ID$3 = 'datepickers.calendar_item';
var retrieveSize = function retrieveSize(_ref) {
  var isCompact = _ref.isCompact,
      theme = _ref.theme;
  var size;
  if (isCompact) {
    size = "".concat(theme.space.base * 8, "px");
  } else {
    size = "".concat(theme.space.base * 10, "px");
  }
  return css(["width:", ";height:", ";"], size, size);
};
var StyledCalendarItem = styled.div.attrs({
  'data-garden-id': COMPONENT_ID$3
}).withConfig({
  displayName: "StyledCalendarItem",
  componentId: "sc-143w8wb-0"
})(["display:inline-block;position:relative;vertical-align:top;", " ", ";"], retrieveSize, function (props) {
  return retrieveComponentStyles(COMPONENT_ID$3, props);
});
StyledCalendarItem.defaultProps = {
  theme: DEFAULT_THEME
};

var COMPONENT_ID$2 = 'datepickers.day_label';
var StyledDayLabel = styled.div.attrs({
  'data-garden-id': COMPONENT_ID$2
}).withConfig({
  displayName: "StyledDayLabel",
  componentId: "sc-9bh1p7-0"
})(["display:flex;align-items:center;justify-content:center;width:100%;height:100%;font-size:", ";font-weight:", ";", ";"], function (props) {
  return props.isCompact ? props.theme.fontSizes.sm : props.theme.fontSizes.md;
}, function (props) {
  return props.theme.fontWeights.semibold;
}, function (props) {
  return retrieveComponentStyles(COMPONENT_ID$2, props);
});
StyledDayLabel.defaultProps = {
  theme: DEFAULT_THEME
};

var COMPONENT_ID$1 = 'datepickers.highlight';
var retrieveBorderRadius = function retrieveBorderRadius(_ref) {
  var theme = _ref.theme,
      isEnd = _ref.isEnd,
      isStart = _ref.isStart;
  var startValue = 'border-radius: 0 50% 50% 0;';
  var endValue = 'border-radius: 50% 0 0 50%;';
  if (theme.rtl) {
    if (isStart) {
      return startValue;
    } else if (isEnd) {
      return endValue;
    }
  }
  if (isStart) {
    return endValue;
  } else if (isEnd) {
    return startValue;
  }
  return '';
};
var retrieveColor = function retrieveColor(_ref2) {
  var isHighlighted = _ref2.isHighlighted,
      theme = _ref2.theme;
  if (isHighlighted) {
    return css(["background-color:", ";"], getColor('primaryHue', 600, theme, 0.08));
  }
  return css([""]);
};
var StyledHighlight = styled.div.attrs({
  'data-garden-id': COMPONENT_ID$1
}).withConfig({
  displayName: "StyledHighlight",
  componentId: "sc-16vr32x-0"
})(["position:absolute;top:0;left:0;width:100%;height:100%;", " ", " ", ";"], retrieveBorderRadius, retrieveColor, function (props) {
  return retrieveComponentStyles(COMPONENT_ID$1, props);
});
StyledHighlight.defaultProps = {
  theme: DEFAULT_THEME
};

var retrieveStyledDayColors = function retrieveStyledDayColors(_ref) {
  var isSelected = _ref.isSelected,
      isDisabled = _ref.isDisabled,
      isToday = _ref.isToday,
      isPreviousMonth = _ref.isPreviousMonth,
      theme = _ref.theme;
  var backgroundColor = 'inherit';
  var color = getColor('primaryHue', 600, theme);
  if (isSelected && !isDisabled) {
    backgroundColor = getColor('primaryHue', 600, theme);
    color = theme.colors.background;
  } else if (isDisabled) {
    color = getColor('neutralHue', 400, theme);
  } else if (isToday) {
    color = 'inherit';
  } else if (isPreviousMonth) {
    color = getColor('neutralHue', 600, theme);
  }
  return css(["background-color:", ";color:", ";", ""], backgroundColor, color, !isSelected && !isDisabled && "\n      :hover {\n        background-color: ".concat(getColor('primaryHue', 600, theme, 0.08), ";\n        color: ").concat(getColor('primaryHue', 800, theme), ";\n      }\n\n      :active {\n        background-color: ").concat(getColor('primaryHue', 600, theme, 0.2), ";\n        color: ").concat(getColor('primaryHue', 800, theme), ";\n      }\n  "));
};
var COMPONENT_ID = 'datepickers.day';
var StyledDay = styled.div.attrs(function (props) {
  return {
    'data-garden-id': COMPONENT_ID,
    'aria-disabled': props.isDisabled ? 'true' : 'false'
  };
}).withConfig({
  displayName: "StyledDay",
  componentId: "sc-v42uk5-0"
})(["display:flex;position:absolute;align-items:center;justify-content:center;border-radius:50%;cursor:", ";width:100%;height:100%;font-size:", ";font-weight:", ";", " ", ";"], function (props) {
  return props.isDisabled ? 'inherit' : 'pointer';
}, function (props) {
  return props.isCompact ? props.theme.fontSizes.sm : props.theme.fontSizes.md;
}, function (props) {
  return props.isToday && !props.isDisabled ? props.theme.fontWeights.semibold : 'inherit';
}, retrieveStyledDayColors, function (props) {
  return retrieveComponentStyles(COMPONENT_ID, props);
});
StyledDay.defaultProps = {
  theme: DEFAULT_THEME
};

var DatepickerContext = createContext(undefined);
var useDatepickerContext$1 = function useDatepickerContext() {
  return useContext(DatepickerContext);
};

var REGION_MAPPINGS = {
  'ar-DZ': 0,
  'ar-SA': 0,
  'en-CA': 0,
  'en-GB': 1,
  'en-US': 0,
  'fa-IR': 0,
  'fr-CH': 1,
  'nl-BE': 1,
  'pt-BR': 0,
  'zh-CN': 1,
  'zh-TW': 1
};
var LANGUAGE_MAPPINGS = {
  af: 0,
  ar: 6,
  be: 1,
  bg: 1,
  bn: 0,
  ca: 1,
  cs: 1,
  da: 1,
  de: 1,
  el: 1,
  en: 0,
  eo: 1,
  es: 1,
  et: 1,
  fa: 0,
  fi: 1,
  fil: 0,
  fr: 1,
  gl: 1,
  he: 0,
  hr: 1,
  hu: 1,
  id: 1,
  is: 1,
  it: 1,
  ja: 1,
  ka: 1,
  ko: 0,
  lt: 1,
  lv: 1,
  mk: 1,
  ms: 1,
  nb: 1,
  nl: 1,
  nn: 1,
  pl: 1,
  pt: 0,
  ro: 1,
  ru: 1,
  sk: 1,
  sl: 1,
  sr: 1,
  sv: 1,
  th: 1,
  tr: 1,
  ug: 0,
  uk: 1,
  vi: 1,
  zh: 1
};
function getStartOfWeek(locale) {
  if (!locale) {
    return 0;
  }
  for (var region in REGION_MAPPINGS) {
    if (locale.startsWith(region)) {
      return REGION_MAPPINGS[region];
    }
  }
  for (var language in LANGUAGE_MAPPINGS) {
    if (locale.startsWith(language)) {
      return LANGUAGE_MAPPINGS[language];
    }
  }
  return 0;
}

function _extends$1() { _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$1.apply(this, arguments); }

var _ref$1 = /*#__PURE__*/React.createElement("path", {
  fill: "currentColor",
  d: "M10.39 12.688a.5.5 0 01-.718.69l-.062-.066-4-5a.5.5 0 01-.054-.542l.054-.082 4-5a.5.5 0 01.83.55l-.05.074L6.641 8l3.75 4.688z"
});

function SvgChevronLeftStroke(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$1({
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 16 16",
    focusable: "false",
    role: "presentation"
  }, props), _ref$1);
}

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var _ref = /*#__PURE__*/React.createElement("path", {
  fill: "currentColor",
  d: "M5.61 3.312a.5.5 0 01.718-.69l.062.066 4 5a.5.5 0 01.054.542l-.054.082-4 5a.5.5 0 01-.83-.55l.05-.074L9.359 8l-3.75-4.688z"
});

function SvgChevronRightStroke(props) {
  return /*#__PURE__*/React.createElement("svg", _extends({
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 16 16",
    focusable: "false",
    role: "presentation"
  }, props), _ref);
}

var MonthSelector = function MonthSelector(_ref) {
  var locale = _ref.locale,
      isCompact = _ref.isCompact;
  var _useDatepickerContext = useDatepickerContext$1(),
      state = _useDatepickerContext.state,
      dispatch = _useDatepickerContext.dispatch;
  var headerLabelFormatter = useCallback(function (date) {
    var formatter = new Intl.DateTimeFormat(locale, {
      month: 'long',
      year: 'numeric'
    });
    return formatter.format(date);
  }, [locale]);
  return React__default.createElement(StyledHeader, {
    isCompact: isCompact
  }, React__default.createElement(StyledHeaderPaddle, {
    isCompact: isCompact,
    onClick: function onClick() {
      dispatch({
        type: 'PREVIEW_PREVIOUS_MONTH'
      });
    }
  }, React__default.createElement(SvgChevronLeftStroke, null)), React__default.createElement(StyledHeaderLabel, {
    isCompact: isCompact
  }, headerLabelFormatter(state.previewDate)), React__default.createElement(StyledHeaderPaddle, {
    isCompact: isCompact,
    onClick: function onClick() {
      dispatch({
        type: 'PREVIEW_NEXT_MONTH'
      });
    }
  }, React__default.createElement(SvgChevronRightStroke, null)));
};

var Calendar$1 = function Calendar(_ref) {
  var value = _ref.value,
      minValue = _ref.minValue,
      maxValue = _ref.maxValue,
      isCompact = _ref.isCompact,
      locale = _ref.locale;
  var _useDatepickerContext = useDatepickerContext$1(),
      state = _useDatepickerContext.state,
      dispatch = _useDatepickerContext.dispatch;
  var weekStartsOn = getStartOfWeek(locale);
  var monthStartDate = startOfMonth(state.previewDate);
  var monthEndDate = endOfMonth(monthStartDate);
  var startDate = startOfWeek(monthStartDate, {
    weekStartsOn: weekStartsOn
  });
  var endDate = endOfWeek(monthEndDate, {
    weekStartsOn: weekStartsOn
  });
  var dayLabelFormatter = useCallback(function (date) {
    var formatter = new Intl.DateTimeFormat(locale, {
      weekday: 'short'
    });
    return formatter.format(date);
  }, [locale]);
  var dayLabels = eachDayOfInterval({
    start: startDate,
    end: addDays(startDate, 6)
  }).map(function (date) {
    var formattedDayLabel = dayLabelFormatter(date);
    return React__default.createElement(StyledCalendarItem, {
      key: "day-label-".concat(formattedDayLabel),
      isCompact: isCompact
    }, React__default.createElement(StyledDayLabel, {
      isCompact: isCompact
    }, formattedDayLabel));
  });
  var items = eachDayOfInterval({
    start: startDate,
    end: endDate
  }).map(function (date, itemsIndex) {
    var formattedDayLabel = getDate(date);
    var isCurrentDate = isToday(date);
    var isPreviousMonth = !isSameMonth(date, state.previewDate);
    var isSelected = value && isSameDay(date, value);
    var isDisabled = false;
    if (minValue !== undefined) {
      isDisabled = isBefore(date, minValue) && !isSameDay(date, minValue);
    }
    if (maxValue !== undefined) {
      isDisabled = isDisabled || isAfter(date, maxValue) && !isSameDay(date, maxValue);
    }
    return React__default.createElement(StyledCalendarItem, {
      key: "day-".concat(itemsIndex),
      isCompact: isCompact
    }, React__default.createElement(StyledDay, {
      isToday: isCurrentDate,
      isPreviousMonth: isPreviousMonth,
      isSelected: isSelected,
      isDisabled: isDisabled,
      isCompact: isCompact,
      onClick: function onClick() {
        if (!isDisabled) {
          dispatch({
            type: 'SELECT_DATE',
            value: date
          });
        }
      }
    }, formattedDayLabel));
  });
  return React__default.createElement(StyledDatepicker, {
    isCompact: isCompact,
    onMouseDown: function onMouseDown(e) {
      e.preventDefault();
    }
  }, React__default.createElement(MonthSelector, {
    locale: locale,
    isCompact: isCompact
  }), React__default.createElement(StyledCalendar, {
    isCompact: isCompact
  }, dayLabels, items));
};

function addMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  var dayOfMonth = date.getDate();
  var endOfDesiredMonth = new Date(date.getTime());
  endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
  var daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  } else {
    date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
    return date;
  }
}

function subMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, -amount);
}

function isValid(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  return !isNaN(date);
}

var formatDistanceLocale = {
  lessThanXSeconds: {
    one: 'less than a second',
    other: 'less than {{count}} seconds'
  },
  xSeconds: {
    one: '1 second',
    other: '{{count}} seconds'
  },
  halfAMinute: 'half a minute',
  lessThanXMinutes: {
    one: 'less than a minute',
    other: 'less than {{count}} minutes'
  },
  xMinutes: {
    one: '1 minute',
    other: '{{count}} minutes'
  },
  aboutXHours: {
    one: 'about 1 hour',
    other: 'about {{count}} hours'
  },
  xHours: {
    one: '1 hour',
    other: '{{count}} hours'
  },
  xDays: {
    one: '1 day',
    other: '{{count}} days'
  },
  aboutXWeeks: {
    one: 'about 1 week',
    other: 'about {{count}} weeks'
  },
  xWeeks: {
    one: '1 week',
    other: '{{count}} weeks'
  },
  aboutXMonths: {
    one: 'about 1 month',
    other: 'about {{count}} months'
  },
  xMonths: {
    one: '1 month',
    other: '{{count}} months'
  },
  aboutXYears: {
    one: 'about 1 year',
    other: 'about {{count}} years'
  },
  xYears: {
    one: '1 year',
    other: '{{count}} years'
  },
  overXYears: {
    one: 'over 1 year',
    other: 'over {{count}} years'
  },
  almostXYears: {
    one: 'almost 1 year',
    other: 'almost {{count}} years'
  }
};
function formatDistance(token, count, options) {
  options = options || {};
  var result;
  if (typeof formatDistanceLocale[token] === 'string') {
    result = formatDistanceLocale[token];
  } else if (count === 1) {
    result = formatDistanceLocale[token].one;
  } else {
    result = formatDistanceLocale[token].other.replace('{{count}}', count);
  }
  if (options.addSuffix) {
    if (options.comparison > 0) {
      return 'in ' + result;
    } else {
      return result + ' ago';
    }
  }
  return result;
}

function buildFormatLongFn(args) {
  return function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format = args.formats[width] || args.formats[args.defaultWidth];
    return format;
  };
}

var dateFormats = {
  full: 'EEEE, MMMM do, y',
  long: 'MMMM do, y',
  medium: 'MMM d, y',
  short: 'MM/dd/yyyy'
};
var timeFormats = {
  full: 'h:mm:ss a zzzz',
  long: 'h:mm:ss a z',
  medium: 'h:mm:ss a',
  short: 'h:mm a'
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: '{{date}}, {{time}}',
  short: '{{date}}, {{time}}'
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: 'full'
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: 'full'
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: 'full'
  })
};
var formatLong$1 = formatLong;

var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: 'P'
};
function formatRelative(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
}

function buildLocalizeFn(args) {
  return function (dirtyIndex, dirtyOptions) {
    var options = dirtyOptions || {};
    var context = options.context ? String(options.context) : 'standalone';
    var valuesArray;
    if (context === 'formatting' && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index];
  };
}

var eraValues = {
  narrow: ['B', 'A'],
  abbreviated: ['BC', 'AD'],
  wide: ['Before Christ', 'Anno Domini']
};
var quarterValues = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
  wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
};
var monthValues = {
  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
};
var dayValues = {
  narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
};
var dayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  }
};
function ordinalNumber(dirtyNumber, _dirtyOptions) {
  var number = Number(dirtyNumber);
  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + 'st';
      case 2:
        return number + 'nd';
      case 3:
        return number + 'rd';
    }
  }
  return number + 'th';
}
var localize = {
  ordinalNumber: ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: 'wide'
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: 'wide',
    argumentCallback: function (quarter) {
      return Number(quarter) - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: 'wide'
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: 'wide'
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: 'wide'
  })
};
var localize$1 = localize;

function buildMatchPatternFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

function buildMatchFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}
function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
  return undefined;
}
function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return undefined;
}

var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function (value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns,
    defaultParseWidth: 'any'
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: 'any',
    valueCallback: function (index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: 'any'
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns,
    defaultParseWidth: 'any'
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: 'any',
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: 'any'
  })
};
var match$1 = match;

var locale = {
  code: 'en-US',
  formatDistance: formatDistance,
  formatLong: formatLong$1,
  formatRelative: formatRelative,
  localize: localize$1,
  match: match$1,
  options: {
    weekStartsOn: 0
    ,
    firstWeekContainsDate: 1
  }
};
var defaultLocale = locale;

function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}

function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}

function assign(target, dirtyObject) {
  if (target == null) {
    throw new TypeError('assign requires that input parameter not be null or undefined');
  }
  dirtyObject = dirtyObject || {};
  for (var property in dirtyObject) {
    if (Object.prototype.hasOwnProperty.call(dirtyObject, property)) {
      target[property] = dirtyObject[property];
    }
  }
  return target;
}

function dateLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'P':
      return formatLong.date({
        width: 'short'
      });
    case 'PP':
      return formatLong.date({
        width: 'medium'
      });
    case 'PPP':
      return formatLong.date({
        width: 'long'
      });
    case 'PPPP':
    default:
      return formatLong.date({
        width: 'full'
      });
  }
}
function timeLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'p':
      return formatLong.time({
        width: 'short'
      });
    case 'pp':
      return formatLong.time({
        width: 'medium'
      });
    case 'ppp':
      return formatLong.time({
        width: 'long'
      });
    case 'pppp':
    default:
      return formatLong.time({
        width: 'full'
      });
  }
}
function dateTimeLongFormatter(pattern, formatLong) {
  var matchResult = pattern.match(/(P+)(p+)?/);
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case 'P':
      dateTimeFormat = formatLong.dateTime({
        width: 'short'
      });
      break;
    case 'PP':
      dateTimeFormat = formatLong.dateTime({
        width: 'medium'
      });
      break;
    case 'PPP':
      dateTimeFormat = formatLong.dateTime({
        width: 'long'
      });
      break;
    case 'PPPP':
    default:
      dateTimeFormat = formatLong.dateTime({
        width: 'full'
      });
      break;
  }
  return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
}
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
var longFormatters$1 = longFormatters;

function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}

var protectedDayOfYearTokens = ['D', 'DD'];
var protectedWeekYearTokens = ['YY', 'YYYY'];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format, input) {
  if (token === 'YYYY') {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === 'YY') {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === 'D') {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === 'DD') {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  }
}

function startOfUTCWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

function getUTCWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate, dirtyOptions);
  var year = date.getUTCFullYear();
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }
  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, dirtyOptions);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, dirtyOptions);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

function setUTCDay(dirtyDate, dirtyDay, dirtyOptions) {
  requiredArgs(2, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }
  var date = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

function setUTCISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var day = toInteger(dirtyDay);
  if (day % 7 === 0) {
    day = day - 7;
  }
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}

var MILLISECONDS_IN_WEEK$1 = 604800000;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
}

function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff = getUTCISOWeek(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

function startOfUTCWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  var year = getUTCWeekYear(dirtyDate, dirtyOptions);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, dirtyOptions);
  return date;
}

var MILLISECONDS_IN_WEEK = 604800000;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

function setUTCWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff = getUTCWeek(date, options) - week;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

var MILLISECONDS_IN_HOUR = 3600000;
var MILLISECONDS_IN_MINUTE = 60000;
var MILLISECONDS_IN_SECOND = 1000;
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  date: /^(3[0-1]|[0-2]?\d)/,
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  week: /^(5[0-3]|[0-4]?\d)/,
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  hour11h: /^(1[0-1]|0?\d)/,
  hour12h: /^(1[0-2]|0?\d)/,
  minute: /^[0-5]?\d/,
  second: /^[0-5]?\d/,
  singleDigit: /^\d/,
  twoDigits: /^\d{1,2}/,
  threeDigits: /^\d{1,3}/,
  fourDigits: /^\d{1,4}/,
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  twoDigitsSigned: /^-?\d{1,2}/,
  threeDigitsSigned: /^-?\d{1,3}/,
  fourDigitsSigned: /^-?\d{1,4}/
};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function parseNumericPattern(pattern, string, valueCallback) {
  var matchResult = string.match(pattern);
  if (!matchResult) {
    return null;
  }
  var value = parseInt(matchResult[0], 10);
  return {
    value: valueCallback ? valueCallback(value) : value,
    rest: string.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, string) {
  var matchResult = string.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === 'Z') {
    return {
      value: 0,
      rest: string.slice(1)
    };
  }
  var sign = matchResult[1] === '+' ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * MILLISECONDS_IN_SECOND),
    rest: string.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(string, valueCallback) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, string, valueCallback);
}
function parseNDigits(n, string, valueCallback) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, string, valueCallback);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, string, valueCallback);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, string, valueCallback);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, string, valueCallback);
    default:
      return parseNumericPattern(new RegExp('^\\d{1,' + n + '}'), string, valueCallback);
  }
}
function parseNDigitsSigned(n, string, valueCallback) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, string, valueCallback);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, string, valueCallback);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, string, valueCallback);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, string, valueCallback);
    default:
      return parseNumericPattern(new RegExp('^-?\\d{1,' + n + '}'), string, valueCallback);
  }
}
function dayPeriodEnumToHours(enumValue) {
  switch (enumValue) {
    case 'morning':
      return 4;
    case 'evening':
      return 17;
    case 'pm':
    case 'noon':
    case 'afternoon':
      return 12;
    case 'am':
    case 'midnight':
    case 'night':
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0;
  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
var parsers = {
  G: {
    priority: 140,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'G':
        case 'GG':
        case 'GGG':
          return match.era(string, {
            width: 'abbreviated'
          }) || match.era(string, {
            width: 'narrow'
          });
        case 'GGGGG':
          return match.era(string, {
            width: 'narrow'
          });
        case 'GGGG':
        default:
          return match.era(string, {
            width: 'wide'
          }) || match.era(string, {
            width: 'abbreviated'
          }) || match.era(string, {
            width: 'narrow'
          });
      }
    },
    set: function (date, flags, value, _options) {
      flags.era = value;
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['R', 'u', 't', 'T']
  },
  y: {
    priority: 130,
    parse: function (string, token, match, _options) {
      var valueCallback = function (year) {
        return {
          year: year,
          isTwoDigitYear: token === 'yy'
        };
      };
      switch (token) {
        case 'y':
          return parseNDigits(4, string, valueCallback);
        case 'yo':
          return match.ordinalNumber(string, {
            unit: 'year',
            valueCallback: valueCallback
          });
        default:
          return parseNDigits(token.length, string, valueCallback);
      }
    },
    validate: function (_date, value, _options) {
      return value.isTwoDigitYear || value.year > 0;
    },
    set: function (date, flags, value, _options) {
      var currentYear = date.getUTCFullYear();
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
      var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'u', 'w', 'I', 'i', 'e', 'c', 't', 'T']
  },
  Y: {
    priority: 130,
    parse: function (string, token, match, _options) {
      var valueCallback = function (year) {
        return {
          year: year,
          isTwoDigitYear: token === 'YY'
        };
      };
      switch (token) {
        case 'Y':
          return parseNDigits(4, string, valueCallback);
        case 'Yo':
          return match.ordinalNumber(string, {
            unit: 'year',
            valueCallback: valueCallback
          });
        default:
          return parseNDigits(token.length, string, valueCallback);
      }
    },
    validate: function (_date, value, _options) {
      return value.isTwoDigitYear || value.year > 0;
    },
    set: function (date, flags, value, options) {
      var currentYear = getUTCWeekYear(date, options);
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options);
      }
      var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return startOfUTCWeek(date, options);
    },
    incompatibleTokens: ['y', 'R', 'u', 'Q', 'q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']
  },
  R: {
    priority: 130,
    parse: function (string, token, _match, _options) {
      if (token === 'R') {
        return parseNDigitsSigned(4, string);
      }
      return parseNDigitsSigned(token.length, string);
    },
    set: function (_date, _flags, value, _options) {
      var firstWeekOfYear = new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return startOfUTCISOWeek(firstWeekOfYear);
    },
    incompatibleTokens: ['G', 'y', 'Y', 'u', 'Q', 'q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']
  },
  u: {
    priority: 130,
    parse: function (string, token, _match, _options) {
      if (token === 'u') {
        return parseNDigitsSigned(4, string);
      }
      return parseNDigitsSigned(token.length, string);
    },
    set: function (date, _flags, value, _options) {
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['G', 'y', 'Y', 'R', 'w', 'I', 'i', 'e', 'c', 't', 'T']
  },
  Q: {
    priority: 120,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'Q':
        case 'QQ':
          return parseNDigits(token.length, string);
        case 'Qo':
          return match.ordinalNumber(string, {
            unit: 'quarter'
          });
        case 'QQQ':
          return match.quarter(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.quarter(string, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'QQQQQ':
          return match.quarter(string, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'QQQQ':
        default:
          return match.quarter(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.quarter(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.quarter(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 4;
    },
    set: function (date, _flags, value, _options) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']
  },
  q: {
    priority: 120,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'q':
        case 'qq':
          return parseNDigits(token.length, string);
        case 'qo':
          return match.ordinalNumber(string, {
            unit: 'quarter'
          });
        case 'qqq':
          return match.quarter(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.quarter(string, {
            width: 'narrow',
            context: 'standalone'
          });
        case 'qqqqq':
          return match.quarter(string, {
            width: 'narrow',
            context: 'standalone'
          });
        case 'qqqq':
        default:
          return match.quarter(string, {
            width: 'wide',
            context: 'standalone'
          }) || match.quarter(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.quarter(string, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 4;
    },
    set: function (date, _flags, value, _options) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'Q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']
  },
  M: {
    priority: 110,
    parse: function (string, token, match, _options) {
      var valueCallback = function (value) {
        return value - 1;
      };
      switch (token) {
        case 'M':
          return parseNumericPattern(numericPatterns.month, string, valueCallback);
        case 'MM':
          return parseNDigits(2, string, valueCallback);
        case 'Mo':
          return match.ordinalNumber(string, {
            unit: 'month',
            valueCallback: valueCallback
          });
        case 'MMM':
          return match.month(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.month(string, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'MMMMM':
          return match.month(string, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'MMMM':
        default:
          return match.month(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.month(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.month(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function (date, _flags, value, _options) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'q', 'Q', 'L', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']
  },
  L: {
    priority: 110,
    parse: function (string, token, match, _options) {
      var valueCallback = function (value) {
        return value - 1;
      };
      switch (token) {
        case 'L':
          return parseNumericPattern(numericPatterns.month, string, valueCallback);
        case 'LL':
          return parseNDigits(2, string, valueCallback);
        case 'Lo':
          return match.ordinalNumber(string, {
            unit: 'month',
            valueCallback: valueCallback
          });
        case 'LLL':
          return match.month(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.month(string, {
            width: 'narrow',
            context: 'standalone'
          });
        case 'LLLLL':
          return match.month(string, {
            width: 'narrow',
            context: 'standalone'
          });
        case 'LLLL':
        default:
          return match.month(string, {
            width: 'wide',
            context: 'standalone'
          }) || match.month(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.month(string, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function (date, _flags, value, _options) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'q', 'Q', 'M', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']
  },
  w: {
    priority: 100,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'w':
          return parseNumericPattern(numericPatterns.week, string);
        case 'wo':
          return match.ordinalNumber(string, {
            unit: 'week'
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 53;
    },
    set: function (date, _flags, value, options) {
      return startOfUTCWeek(setUTCWeek(date, value, options), options);
    },
    incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']
  },
  I: {
    priority: 100,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'I':
          return parseNumericPattern(numericPatterns.week, string);
        case 'Io':
          return match.ordinalNumber(string, {
            unit: 'week'
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 53;
    },
    set: function (date, _flags, value, options) {
      return startOfUTCISOWeek(setUTCISOWeek(date, value, options), options);
    },
    incompatibleTokens: ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']
  },
  d: {
    priority: 90,
    subPriority: 1,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'd':
          return parseNumericPattern(numericPatterns.date, string);
        case 'do':
          return match.ordinalNumber(string, {
            unit: 'date'
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (date, value, _options) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex(year);
      var month = date.getUTCMonth();
      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    },
    set: function (date, _flags, value, _options) {
      date.setUTCDate(value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'q', 'Q', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']
  },
  D: {
    priority: 90,
    subPriority: 1,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'D':
        case 'DD':
          return parseNumericPattern(numericPatterns.dayOfYear, string);
        case 'Do':
          return match.ordinalNumber(string, {
            unit: 'date'
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (date, value, _options) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex(year);
      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    },
    set: function (date, _flags, value, _options) {
      date.setUTCMonth(0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'q', 'Q', 'M', 'L', 'w', 'I', 'd', 'E', 'i', 'e', 'c', 't', 'T']
  },
  E: {
    priority: 90,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'E':
        case 'EE':
        case 'EEE':
          return match.day(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'EEEEE':
          return match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'EEEEEE':
          return match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'EEEE':
        default:
          return match.day(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function (date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['D', 'i', 'e', 'c', 't', 'T']
  },
  e: {
    priority: 90,
    parse: function (string, token, match, options) {
      var valueCallback = function (value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        case 'e':
        case 'ee':
          return parseNDigits(token.length, string, valueCallback);
        case 'eo':
          return match.ordinalNumber(string, {
            unit: 'day',
            valueCallback: valueCallback
          });
        case 'eee':
          return match.day(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'eeeee':
          return match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'eeeeee':
          return match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'eeee':
        default:
          return match.day(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function (date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'c', 't', 'T']
  },
  c: {
    priority: 90,
    parse: function (string, token, match, options) {
      var valueCallback = function (value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        case 'c':
        case 'cc':
          return parseNDigits(token.length, string, valueCallback);
        case 'co':
          return match.ordinalNumber(string, {
            unit: 'day',
            valueCallback: valueCallback
          });
        case 'ccc':
          return match.day(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.day(string, {
            width: 'short',
            context: 'standalone'
          }) || match.day(string, {
            width: 'narrow',
            context: 'standalone'
          });
        case 'ccccc':
          return match.day(string, {
            width: 'narrow',
            context: 'standalone'
          });
        case 'cccccc':
          return match.day(string, {
            width: 'short',
            context: 'standalone'
          }) || match.day(string, {
            width: 'narrow',
            context: 'standalone'
          });
        case 'cccc':
        default:
          return match.day(string, {
            width: 'wide',
            context: 'standalone'
          }) || match.day(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.day(string, {
            width: 'short',
            context: 'standalone'
          }) || match.day(string, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function (date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'e', 't', 'T']
  },
  i: {
    priority: 90,
    parse: function (string, token, match, _options) {
      var valueCallback = function (value) {
        if (value === 0) {
          return 7;
        }
        return value;
      };
      switch (token) {
        case 'i':
        case 'ii':
          return parseNDigits(token.length, string);
        case 'io':
          return match.ordinalNumber(string, {
            unit: 'day'
          });
        case 'iii':
          return match.day(string, {
            width: 'abbreviated',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'short',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting',
            valueCallback: valueCallback
          });
        case 'iiiii':
          return match.day(string, {
            width: 'narrow',
            context: 'formatting',
            valueCallback: valueCallback
          });
        case 'iiiiii':
          return match.day(string, {
            width: 'short',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting',
            valueCallback: valueCallback
          });
        case 'iiii':
        default:
          return match.day(string, {
            width: 'wide',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'abbreviated',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'short',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting',
            valueCallback: valueCallback
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 7;
    },
    set: function (date, _flags, value, options) {
      date = setUTCISODay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'E', 'e', 'c', 't', 'T']
  },
  a: {
    priority: 80,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'a':
        case 'aa':
        case 'aaa':
          return match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'aaaaa':
          return match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'aaaa':
        default:
          return match.dayPeriod(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    set: function (date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['b', 'B', 'H', 'K', 'k', 't', 'T']
  },
  b: {
    priority: 80,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'b':
        case 'bb':
        case 'bbb':
          return match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'bbbbb':
          return match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'bbbb':
        default:
          return match.dayPeriod(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    set: function (date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['a', 'B', 'H', 'K', 'k', 't', 'T']
  },
  B: {
    priority: 80,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'B':
        case 'BB':
        case 'BBB':
          return match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'BBBBB':
          return match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'BBBB':
        default:
          return match.dayPeriod(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    set: function (date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['a', 'b', 't', 'T']
  },
  h: {
    priority: 70,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'h':
          return parseNumericPattern(numericPatterns.hour12h, string);
        case 'ho':
          return match.ordinalNumber(string, {
            unit: 'hour'
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 12;
    },
    set: function (date, _flags, value, _options) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    },
    incompatibleTokens: ['H', 'K', 'k', 't', 'T']
  },
  H: {
    priority: 70,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'H':
          return parseNumericPattern(numericPatterns.hour23h, string);
        case 'Ho':
          return match.ordinalNumber(string, {
            unit: 'hour'
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 23;
    },
    set: function (date, _flags, value, _options) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['a', 'b', 'h', 'K', 'k', 't', 'T']
  },
  K: {
    priority: 70,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'K':
          return parseNumericPattern(numericPatterns.hour11h, string);
        case 'Ko':
          return match.ordinalNumber(string, {
            unit: 'hour'
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function (date, _flags, value, _options) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    },
    incompatibleTokens: ['a', 'b', 'h', 'H', 'k', 't', 'T']
  },
  k: {
    priority: 70,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'k':
          return parseNumericPattern(numericPatterns.hour24h, string);
        case 'ko':
          return match.ordinalNumber(string, {
            unit: 'hour'
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 24;
    },
    set: function (date, _flags, value, _options) {
      var hours = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['a', 'b', 'h', 'H', 'K', 't', 'T']
  },
  m: {
    priority: 60,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'm':
          return parseNumericPattern(numericPatterns.minute, string);
        case 'mo':
          return match.ordinalNumber(string, {
            unit: 'minute'
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 59;
    },
    set: function (date, _flags, value, _options) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    },
    incompatibleTokens: ['t', 'T']
  },
  s: {
    priority: 50,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 's':
          return parseNumericPattern(numericPatterns.second, string);
        case 'so':
          return match.ordinalNumber(string, {
            unit: 'second'
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 59;
    },
    set: function (date, _flags, value, _options) {
      date.setUTCSeconds(value, 0);
      return date;
    },
    incompatibleTokens: ['t', 'T']
  },
  S: {
    priority: 30,
    parse: function (string, token, _match, _options) {
      var valueCallback = function (value) {
        return Math.floor(value * Math.pow(10, -token.length + 3));
      };
      return parseNDigits(token.length, string, valueCallback);
    },
    set: function (date, _flags, value, _options) {
      date.setUTCMilliseconds(value);
      return date;
    },
    incompatibleTokens: ['t', 'T']
  },
  X: {
    priority: 10,
    parse: function (string, token, _match, _options) {
      switch (token) {
        case 'X':
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);
        case 'XX':
          return parseTimezonePattern(timezonePatterns.basic, string);
        case 'XXXX':
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);
        case 'XXXXX':
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);
        case 'XXX':
        default:
          return parseTimezonePattern(timezonePatterns.extended, string);
      }
    },
    set: function (date, flags, value, _options) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    },
    incompatibleTokens: ['t', 'T', 'x']
  },
  x: {
    priority: 10,
    parse: function (string, token, _match, _options) {
      switch (token) {
        case 'x':
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);
        case 'xx':
          return parseTimezonePattern(timezonePatterns.basic, string);
        case 'xxxx':
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);
        case 'xxxxx':
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);
        case 'xxx':
        default:
          return parseTimezonePattern(timezonePatterns.extended, string);
      }
    },
    set: function (date, flags, value, _options) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    },
    incompatibleTokens: ['t', 'T', 'X']
  },
  t: {
    priority: 40,
    parse: function (string, _token, _match, _options) {
      return parseAnyDigitsSigned(string);
    },
    set: function (_date, _flags, value, _options) {
      return [new Date(value * 1000), {
        timestampIsSet: true
      }];
    },
    incompatibleTokens: '*'
  },
  T: {
    priority: 20,
    parse: function (string, _token, _match, _options) {
      return parseAnyDigitsSigned(string);
    },
    set: function (_date, _flags, value, _options) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    },
    incompatibleTokens: '*'
  }
};
var parsers$1 = parsers;

var TIMEZONE_UNIT_PRIORITY = 10;
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, dirtyOptions) {
  requiredArgs(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var options = dirtyOptions || {};
  var locale = options.locale || defaultLocale;
  if (!locale.match) {
    throw new RangeError('locale must contain match property');
  }
  var localeFirstWeekContainsDate = locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }
  var localeWeekStartsOn = locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }
  if (formatString === '') {
    if (dateString === '') {
      return toDate(dirtyReferenceDate);
    } else {
      return new Date(NaN);
    }
  }
  var subFnOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale
  };
  var setters = [{
    priority: TIMEZONE_UNIT_PRIORITY,
    subPriority: -1,
    set: dateToSystemTimezone,
    index: 0
  }];
  var i;
  var tokens = formatString.match(longFormattingTokensRegExp).map(function (substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === 'p' || firstCharacter === 'P') {
      var longFormatter = longFormatters$1[firstCharacter];
      return longFormatter(substring, locale.formatLong, subFnOptions);
    }
    return substring;
  }).join('').match(formattingTokensRegExp);
  var usedTokens = [];
  for (i = 0; i < tokens.length; i++) {
    var token = tokens[i];
    if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token)) {
      throwProtectedError(token, formatString, dirtyDateString);
    }
    if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token)) {
      throwProtectedError(token, formatString, dirtyDateString);
    }
    var firstCharacter = token[0];
    var parser = parsers$1[firstCharacter];
    if (parser) {
      var incompatibleTokens = parser.incompatibleTokens;
      if (Array.isArray(incompatibleTokens)) {
        var incompatibleToken = void 0;
        for (var _i = 0; _i < usedTokens.length; _i++) {
          var usedToken = usedTokens[_i].token;
          if (incompatibleTokens.indexOf(usedToken) !== -1 || usedToken === firstCharacter) {
            incompatibleToken = usedTokens[_i];
            break;
          }
        }
        if (incompatibleToken) {
          throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
        }
      } else if (parser.incompatibleTokens === '*' && usedTokens.length) {
        throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
      }
      usedTokens.push({
        token: firstCharacter,
        fullToken: token
      });
      var parseResult = parser.parse(dateString, token, locale.match, subFnOptions);
      if (!parseResult) {
        return new Date(NaN);
      }
      setters.push({
        priority: parser.priority,
        subPriority: parser.subPriority || 0,
        set: parser.set,
        validate: parser.validate,
        value: parseResult.value,
        index: setters.length
      });
      dateString = parseResult.rest;
    } else {
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
      }
      if (token === "''") {
        token = "'";
      } else if (firstCharacter === "'") {
        token = cleanEscapedString(token);
      }
      if (dateString.indexOf(token) === 0) {
        dateString = dateString.slice(token.length);
      } else {
        return new Date(NaN);
      }
    }
  }
  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return new Date(NaN);
  }
  var uniquePrioritySetters = setters.map(function (setter) {
    return setter.priority;
  }).sort(function (a, b) {
    return b - a;
  }).filter(function (priority, index, array) {
    return array.indexOf(priority) === index;
  }).map(function (priority) {
    return setters.filter(function (setter) {
      return setter.priority === priority;
    }).sort(function (a, b) {
      return b.subPriority - a.subPriority;
    });
  }).map(function (setterArray) {
    return setterArray[0];
  });
  var date = toDate(dirtyReferenceDate);
  if (isNaN(date)) {
    return new Date(NaN);
  }
  var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
  var flags = {};
  for (i = 0; i < uniquePrioritySetters.length; i++) {
    var setter = uniquePrioritySetters[i];
    if (setter.validate && !setter.validate(utcDate, setter.value, subFnOptions)) {
      return new Date(NaN);
    }
    var result = setter.set(utcDate, flags, setter.value, subFnOptions);
    if (result[0]) {
      utcDate = result[0];
      assign(flags, result[1]);
    } else {
      utcDate = result;
    }
  }
  return utcDate;
}
function dateToSystemTimezone(date, flags) {
  if (flags.timestampIsSet) {
    return date;
  }
  var convertedDate = new Date(0);
  convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
  convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
  return convertedDate;
}
function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}

function parseInputValue$1(_ref) {
  var inputValue = _ref.inputValue,
      customParseDate = _ref.customParseDate;
  if (customParseDate) {
    return customParseDate(inputValue);
  }
  var MINIMUM_DATE = new Date(1001, 0, 0);
  var tryParseDate = parse(inputValue, 'P', new Date());
  if (isValid(tryParseDate) && !isBefore(tryParseDate, MINIMUM_DATE)) {
    return tryParseDate;
  }
  tryParseDate = parse(inputValue, 'PP', new Date());
  if (isValid(tryParseDate) && !isBefore(tryParseDate, MINIMUM_DATE)) {
    return tryParseDate;
  }
  tryParseDate = parse(inputValue, 'PPP', new Date());
  if (isValid(tryParseDate) && !isBefore(tryParseDate, MINIMUM_DATE)) {
    return tryParseDate;
  }
  return new Date(NaN);
}
function formatInputValue(_ref2) {
  var date = _ref2.date,
      locale = _ref2.locale,
      formatDate = _ref2.formatDate;
  if (!date) {
    return '';
  }
  if (formatDate) {
    return formatDate(date);
  }
  return new Intl.DateTimeFormat(locale, {
    month: 'long',
    day: 'numeric',
    year: 'numeric'
  }).format(date);
}
var datepickerReducer = function datepickerReducer(_ref3) {
  var value = _ref3.value,
      formatDate = _ref3.formatDate,
      locale = _ref3.locale,
      customParseDate = _ref3.customParseDate,
      onChange = _ref3.onChange;
  return function (state, action) {
    switch (action.type) {
      case 'OPEN':
        return _objectSpread2(_objectSpread2({}, state), {}, {
          isOpen: true,
          previewDate: value || new Date()
        });
      case 'CLOSE':
        {
          var inputValue = formatInputValue({
            date: value,
            locale: locale,
            formatDate: formatDate
          });
          return _objectSpread2(_objectSpread2({}, state), {}, {
            isOpen: false,
            inputValue: inputValue
          });
        }
      case 'PREVIEW_NEXT_MONTH':
        {
          var previewDate = addMonths(state.previewDate, 1);
          return _objectSpread2(_objectSpread2({}, state), {}, {
            previewDate: previewDate
          });
        }
      case 'PREVIEW_PREVIOUS_MONTH':
        {
          var _previewDate = subMonths(state.previewDate, 1);
          return _objectSpread2(_objectSpread2({}, state), {}, {
            previewDate: _previewDate
          });
        }
      case 'MANUALLY_UPDATE_INPUT':
        {
          var _inputValue = action.value;
          var currentDate = parseInputValue$1({
            inputValue: _inputValue,
            customParseDate: customParseDate
          });
          if (onChange && currentDate && isValid(currentDate) && !isSameDay(value, currentDate)) {
            onChange(currentDate);
          }
          return _objectSpread2(_objectSpread2({}, state), {}, {
            isOpen: true,
            inputValue: _inputValue
          });
        }
      case 'CONTROLLED_VALUE_CHANGE':
        {
          var _previewDate2 = action.value || new Date();
          var _inputValue2 = formatInputValue({
            date: action.value,
            locale: locale,
            formatDate: formatDate
          });
          return _objectSpread2(_objectSpread2({}, state), {}, {
            previewDate: _previewDate2,
            inputValue: _inputValue2
          });
        }
      case 'CONTROLLED_LOCALE_CHANGE':
        {
          var _inputValue3 = formatInputValue({
            date: value,
            locale: locale,
            formatDate: formatDate
          });
          return _objectSpread2(_objectSpread2({}, state), {}, {
            inputValue: _inputValue3
          });
        }
      case 'SELECT_DATE':
        {
          var _inputValue4 = formatInputValue({
            date: action.value,
            locale: locale,
            formatDate: formatDate
          });
          if (onChange && action.value && isValid(action.value) && !isSameDay(value, action.value)) {
            onChange(action.value);
          }
          return _objectSpread2(_objectSpread2({}, state), {}, {
            isOpen: false,
            inputValue: _inputValue4
          });
        }
      default:
        throw new Error();
    }
  };
};
function retrieveInitialState$1(initialProps) {
  var previewDate = initialProps.value;
  if (previewDate === undefined || !isValid(previewDate)) {
    previewDate = new Date();
  }
  var inputValue = '';
  if (initialProps.value !== undefined) {
    if (initialProps.formatDate) {
      inputValue = initialProps.formatDate(initialProps.value);
    } else {
      inputValue = new Intl.DateTimeFormat(initialProps.locale, {
        month: 'long',
        day: 'numeric',
        year: 'numeric'
      }).format(previewDate);
    }
  }
  return {
    isOpen: false,
    previewDate: previewDate,
    inputValue: inputValue
  };
}

var Datepicker = function Datepicker(props) {
  var children = props.children,
      placement = props.placement,
      popperModifiers = props.popperModifiers,
      eventsEnabled = props.eventsEnabled,
      zIndex = props.zIndex,
      isAnimated = props.isAnimated,
      refKey = props.refKey,
      value = props.value,
      isCompact = props.isCompact,
      onChange = props.onChange,
      formatDate = props.formatDate,
      minValue = props.minValue,
      maxValue = props.maxValue,
      locale = props.locale,
      customParseDate = props.customParseDate;
  var theme = useContext(ThemeContext);
  var memoizedReducer = useCallback(datepickerReducer({
    value: value,
    formatDate: formatDate,
    locale: locale,
    customParseDate: customParseDate,
    onChange: onChange
  }), [value, formatDate, locale, onChange, customParseDate]);
  var _useReducer = useReducer(memoizedReducer, retrieveInitialState$1(props)),
      _useReducer2 = _slicedToArray(_useReducer, 2),
      state = _useReducer2[0],
      dispatch = _useReducer2[1];
  var scheduleUpdateRef = useRef(undefined);
  var inputRef = useRef(null);
  var isInputMouseDownRef = useRef(false);
  useEffect(function () {
    if (state.isOpen && scheduleUpdateRef.current) {
      scheduleUpdateRef.current();
    }
  });
  var _useState = useState(state.isOpen),
      _useState2 = _slicedToArray(_useState, 2),
      isVisible = _useState2[0],
      setVisible = _useState2[1];
  useEffect(function () {
    var timeout;
    if (state.isOpen) {
      setVisible(true);
    } else if (isAnimated) {
      timeout = setTimeout(function () {
        return setVisible(false);
      }, 200);
    } else {
      setVisible(false);
    }
    return function () {
      return clearTimeout(timeout);
    };
  }, [state.isOpen, isAnimated]);
  useEffect(function () {
    dispatch({
      type: 'CONTROLLED_VALUE_CHANGE',
      value: value
    });
  }, [value]);
  useEffect(function () {
    dispatch({
      type: 'CONTROLLED_LOCALE_CHANGE'
    });
  }, [locale]);
  var popperPlacement = theme.rtl ? getRtlPopperPlacement(placement) : getPopperPlacement(placement);
  var contextValue = useMemo(function () {
    return {
      state: state,
      dispatch: dispatch
    };
  }, [state, dispatch]);
  return React__default.createElement(DatepickerContext.Provider, {
    value: contextValue
  }, React__default.createElement(Manager, null, React__default.createElement(Reference, null, function (_ref) {
    var _React$cloneElement;
    var ref = _ref.ref;
    var childElement = React__default.Children.only(children);
    return React__default.cloneElement(childElement, (_React$cloneElement = {}, _defineProperty(_React$cloneElement, refKey, function (refValue) {
      ref(refValue);
      inputRef.current = refValue;
    }), _defineProperty(_React$cloneElement, "onMouseDown", composeEventHandlers(childElement.props.onMouseDown, function () {
      isInputMouseDownRef.current = true;
    })), _defineProperty(_React$cloneElement, "onMouseUp", composeEventHandlers(childElement.props.onMouseUp, function () {
      setTimeout(function () {
        isInputMouseDownRef.current = false;
      }, 0);
    })), _defineProperty(_React$cloneElement, "onClick", composeEventHandlers(childElement.props.onClick, function () {
      if (isInputMouseDownRef.current && !state.isOpen) {
        dispatch({
          type: 'OPEN'
        });
      }
    })), _defineProperty(_React$cloneElement, "onBlur", composeEventHandlers(childElement.props.onBlur, function () {
      dispatch({
        type: 'CLOSE'
      });
    })), _defineProperty(_React$cloneElement, "onChange", composeEventHandlers(childElement.props.onChange, function (e) {
      dispatch({
        type: 'MANUALLY_UPDATE_INPUT',
        value: e.target.value
      });
    })), _defineProperty(_React$cloneElement, "onKeyDown", composeEventHandlers(childElement.props.onKeyDown, function (e) {
      switch (e.keyCode) {
        case KEY_CODES.ESCAPE:
        case KEY_CODES.ENTER:
          dispatch({
            type: 'CLOSE'
          });
          break;
        case KEY_CODES.UP:
        case KEY_CODES.DOWN:
        case KEY_CODES.SPACE:
          dispatch({
            type: 'OPEN'
          });
          break;
      }
    })), _defineProperty(_React$cloneElement, "autoComplete", 'off'), _defineProperty(_React$cloneElement, "value", state.inputValue), _React$cloneElement));
  }), React__default.createElement(Popper, {
    placement: popperPlacement,
    modifiers: popperModifiers
    ,
    eventsEnabled: state.isOpen && eventsEnabled
  }, function (_ref2) {
    var ref = _ref2.ref,
        style = _ref2.style,
        scheduleUpdate = _ref2.scheduleUpdate,
        currentPlacement = _ref2.placement;
    scheduleUpdateRef.current = scheduleUpdate;
    return React__default.createElement(StyledMenuWrapper, {
      ref: ref,
      style: style,
      isHidden: !state.isOpen,
      isAnimated: isAnimated && (state.isOpen || isVisible),
      placement: currentPlacement,
      zIndex: zIndex
    }, (state.isOpen || isVisible) && React__default.createElement(StyledMenu, null, React__default.createElement(Calendar$1, {
      isCompact: isCompact,
      value: value,
      minValue: minValue,
      maxValue: maxValue,
      locale: locale
    })));
  })));
};
Datepicker.propTypes = {
  value: PropTypes.any,
  onChange: PropTypes.any,
  formatDate: PropTypes.func,
  locale: PropTypes.any,
  minValue: PropTypes.any,
  maxValue: PropTypes.any,
  isCompact: PropTypes.bool,
  customParseDate: PropTypes.any,
  refKey: PropTypes.string,
  placement: PropTypes.oneOf(['auto', 'top', 'top-start', 'top-end', 'end', 'end-top', 'end-bottom', 'bottom', 'bottom-start', 'bottom-end', 'start', 'start-top', 'start-bottom']),
  popperModifiers: PropTypes.any,
  isAnimated: PropTypes.bool,
  eventsEnabled: PropTypes.bool,
  zIndex: PropTypes.number
};
Datepicker.defaultProps = {
  placement: 'bottom-start',
  refKey: 'ref',
  isAnimated: true,
  eventsEnabled: true,
  zIndex: 1000,
  locale: 'en-US'
};

function compareAsc(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var diff = dateLeft.getTime() - dateRight.getTime();
  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1;
  } else {
    return diff;
  }
}

function formatValue(_ref) {
  var value = _ref.value,
      locale = _ref.locale,
      formatDate = _ref.formatDate;
  var stringValue = '';
  if (value !== undefined && isValid(value)) {
    if (formatDate) {
      stringValue = formatDate(value);
    } else {
      stringValue = new Intl.DateTimeFormat(locale, {
        month: 'long',
        day: 'numeric',
        year: 'numeric'
      }).format(value);
    }
  }
  return stringValue;
}
function parseInputValue(_ref2) {
  var inputValue = _ref2.inputValue;
  var MINIMUM_DATE = new Date(1001, 0, 0);
  var tryParseDate = parse(inputValue || '', 'P', new Date());
  if (isValid(tryParseDate) && !isBefore(tryParseDate, MINIMUM_DATE)) {
    return tryParseDate;
  }
  tryParseDate = parse(inputValue || '', 'PP', new Date());
  if (isValid(tryParseDate) && !isBefore(tryParseDate, MINIMUM_DATE)) {
    return tryParseDate;
  }
  tryParseDate = parse(inputValue || '', 'PPP', new Date());
  if (isValid(tryParseDate) && !isBefore(tryParseDate, MINIMUM_DATE)) {
    return tryParseDate;
  }
  return new Date(NaN);
}
var datepickerRangeReducer = function datepickerRangeReducer(_ref3) {
  var startValue = _ref3.startValue,
      endValue = _ref3.endValue,
      locale = _ref3.locale,
      formatDate = _ref3.formatDate,
      onChange = _ref3.onChange,
      customParseDate = _ref3.customParseDate;
  return function (state, action) {
    switch (action.type) {
      case 'START_FOCUS':
        {
          var previewDate = state.previewDate;
          if (startValue) {
            if (compareAsc(startValue, startOfMonth(state.previewDate)) === 1 && compareAsc(startValue, addMonths(endOfMonth(state.previewDate), 1)) === -1) {
              previewDate = state.previewDate;
            } else {
              previewDate = startOfMonth(startValue);
            }
          }
          return _objectSpread2(_objectSpread2({}, state), {}, {
            previewDate: previewDate,
            isStartFocused: true,
            isEndFocused: false
          });
        }
      case 'END_FOCUS':
        {
          var _previewDate = state.previewDate;
          if (endValue) {
            if (compareAsc(endValue, startOfMonth(state.previewDate)) === 1 && compareAsc(endValue, addMonths(endOfMonth(state.previewDate), 1)) === -1) {
              _previewDate = state.previewDate;
            } else {
              _previewDate = startOfMonth(endValue);
            }
          }
          return _objectSpread2(_objectSpread2({}, state), {}, {
            previewDate: _previewDate,
            isEndFocused: true,
            isStartFocused: false
          });
        }
      case 'START_BLUR':
        {
          var parsedDate;
          if (customParseDate) {
            parsedDate = customParseDate(state.startInputValue);
          } else {
            parsedDate = parseInputValue({
              inputValue: state.startInputValue
            });
          }
          if (onChange && parsedDate && isValid(parsedDate) && !isSameDay(parsedDate, startValue)) {
            onChange({
              startValue: parsedDate,
              endValue: endValue
            });
          }
          var startInputValue = formatValue({
            value: parsedDate,
            locale: locale,
            formatDate: formatDate
          });
          return _objectSpread2(_objectSpread2({}, state), {}, {
            startInputValue: startInputValue || formatValue({
              value: startValue,
              locale: locale,
              formatDate: formatDate
            }),
            isStartFocused: false
          });
        }
      case 'END_BLUR':
        {
          var _parsedDate;
          if (customParseDate) {
            _parsedDate = customParseDate(state.endInputValue);
          } else {
            _parsedDate = parseInputValue({
              inputValue: state.endInputValue
            });
          }
          if (onChange && _parsedDate && isValid(_parsedDate) && !isSameDay(_parsedDate, endValue)) {
            onChange({
              startValue: startValue,
              endValue: _parsedDate
            });
          }
          var endInputValue = formatValue({
            value: _parsedDate,
            locale: locale,
            formatDate: formatDate
          }) || formatValue({
            value: endValue,
            locale: locale,
            formatDate: formatDate
          });
          return _objectSpread2(_objectSpread2({}, state), {}, {
            endInputValue: endInputValue,
            isEndFocused: false
          });
        }
      case 'CONTROLLED_START_VALUE_CHANGE':
        {
          var _startInputValue = formatValue({
            value: action.value,
            locale: locale,
            formatDate: formatDate
          });
          var _previewDate2 = state.previewDate;
          if (action.value) {
            if (compareAsc(action.value, startOfMonth(state.previewDate)) === 1 && compareAsc(action.value, addMonths(endOfMonth(state.previewDate), 1)) === -1) {
              _previewDate2 = state.previewDate;
            } else {
              _previewDate2 = startOfMonth(action.value);
            }
          }
          return _objectSpread2(_objectSpread2({}, state), {}, {
            startInputValue: _startInputValue,
            hoverDate: undefined,
            previewDate: _previewDate2
          });
        }
      case 'CONTROLLED_END_VALUE_CHANGE':
        {
          var _endInputValue = formatValue({
            value: action.value,
            locale: locale,
            formatDate: formatDate
          });
          var _previewDate3 = state.previewDate;
          if (action.value) {
            if (compareAsc(action.value, startOfMonth(state.previewDate)) === 1 && compareAsc(action.value, addMonths(endOfMonth(state.previewDate), 1)) === -1) {
              _previewDate3 = state.previewDate;
            } else {
              _previewDate3 = startOfMonth(action.value);
            }
          }
          return _objectSpread2(_objectSpread2({}, state), {}, {
            endInputValue: _endInputValue,
            hoverDate: undefined,
            previewDate: _previewDate3
          });
        }
      case 'CLICK_DATE':
        if (onChange) {
          if (state.isStartFocused) {
            if (endValue !== undefined && (isBefore(action.value, endValue) || isSameDay(action.value, endValue))) {
              onChange({
                startValue: action.value,
                endValue: endValue
              });
            } else {
              onChange({
                startValue: action.value,
                endValue: undefined
              });
            }
          } else if (state.isEndFocused) {
            if (startValue !== undefined && (isAfter(action.value, startValue) || isSameDay(action.value, startValue))) {
              onChange({
                startValue: startValue,
                endValue: action.value
              });
            } else {
              onChange({
                startValue: action.value,
                endValue: undefined
              });
            }
          } else if (startValue === undefined) {
            onChange({
              startValue: action.value,
              endValue: undefined
            });
          } else if (endValue === undefined) {
            if (isBefore(action.value, startValue)) {
              onChange({
                startValue: action.value,
                endValue: undefined
              });
            } else {
              onChange({
                startValue: startValue,
                endValue: action.value
              });
            }
          } else {
            onChange({
              startValue: action.value,
              endValue: undefined
            });
          }
        }
        return state;
      case 'START_INPUT_ONCHANGE':
        {
          return _objectSpread2(_objectSpread2({}, state), {}, {
            startInputValue: action.value
          });
        }
      case 'END_INPUT_ONCHANGE':
        {
          return _objectSpread2(_objectSpread2({}, state), {}, {
            endInputValue: action.value
          });
        }
      case 'HOVER_DATE':
        return _objectSpread2(_objectSpread2({}, state), {}, {
          hoverDate: action.value
        });
      case 'PREVIEW_NEXT_MONTH':
        {
          var _previewDate4 = addMonths(state.previewDate, 1);
          return _objectSpread2(_objectSpread2({}, state), {}, {
            previewDate: _previewDate4,
            hoverDate: undefined
          });
        }
      case 'PREVIEW_PREVIOUS_MONTH':
        {
          var _previewDate5 = subMonths(state.previewDate, 1);
          return _objectSpread2(_objectSpread2({}, state), {}, {
            previewDate: _previewDate5,
            hoverDate: undefined
          });
        }
      default:
        throw new Error();
    }
  };
};
function retrieveInitialState(initialProps) {
  var previewDate = initialProps.startValue;
  if (previewDate === undefined || !isValid(previewDate)) {
    previewDate = new Date();
  }
  var startInputValue = formatValue({
    value: initialProps.startValue,
    locale: initialProps.locale,
    formatDate: initialProps.formatDate
  });
  var endInputValue = formatValue({
    value: initialProps.endValue,
    locale: initialProps.locale,
    formatDate: initialProps.formatDate
  });
  return {
    previewDate: previewDate,
    startInputValue: startInputValue,
    endInputValue: endInputValue,
    isStartFocused: false,
    isEndFocused: false
  };
}

var DatepickerRangeContext = createContext(undefined);
var useDatepickerContext = function useDatepickerContext() {
  return useContext(DatepickerRangeContext);
};

var Start = function Start(props) {
  var _useDatepickerRangeCo = useDatepickerContext(),
      state = _useDatepickerRangeCo.state,
      dispatch = _useDatepickerRangeCo.dispatch,
      startInputRef = _useDatepickerRangeCo.startInputRef;
  var onChangeCallback = useCallback(function (e) {
    dispatch({
      type: 'START_INPUT_ONCHANGE',
      value: e.target.value
    });
    props.children.props.onChange && props.children.props.onChange(e);
  }, [dispatch, props.children]);
  var onFocusCallback = useCallback(function (e) {
    dispatch({
      type: 'START_FOCUS'
    });
    props.children.props.onFocus && props.children.props.onFocus(e);
  }, [dispatch, props.children]);
  var onKeyDownCallback = useCallback(function (e) {
    if (e.keyCode === KEY_CODES.ENTER) {
      dispatch({
        type: 'START_BLUR'
      });
      e.preventDefault();
    }
    props.children.props.onKeyDown && props.children.props.onKeyDown(e);
  }, [dispatch, props.children]);
  var onBlurCallback = useCallback(function (e) {
    dispatch({
      type: 'START_BLUR'
    });
    props.children.props.onBlur && props.children.props.onBlur(e);
  }, [dispatch, props.children]);
  var childElement = React__default.Children.only(props.children);
  return React__default.cloneElement(childElement, {
    value: state.startInputValue,
    ref: startInputRef,
    onChange: composeEventHandlers(childElement.props.onChange, onChangeCallback),
    onFocus: composeEventHandlers(childElement.props.onFocus, onFocusCallback),
    onKeyDown: composeEventHandlers(childElement.props.onKeyDown, onKeyDownCallback),
    onBlur: composeEventHandlers(childElement.props.onBlur, onBlurCallback)
  });
};

var End = function End(props) {
  var _useDatepickerRangeCo = useDatepickerContext(),
      state = _useDatepickerRangeCo.state,
      dispatch = _useDatepickerRangeCo.dispatch,
      endInputRef = _useDatepickerRangeCo.endInputRef;
  var onChangeCallback = useCallback(function (e) {
    dispatch({
      type: 'END_INPUT_ONCHANGE',
      value: e.target.value
    });
    props.children.props.onChange && props.children.props.onChange(e);
  }, [dispatch, props.children]);
  var onFocusCallback = useCallback(function (e) {
    dispatch({
      type: 'END_FOCUS'
    });
    props.children.props.onFocus && props.children.props.onFocus(e);
  }, [dispatch, props.children]);
  var onKeydownCallback = useCallback(function (e) {
    if (e.keyCode === KEY_CODES.ENTER) {
      dispatch({
        type: 'END_BLUR'
      });
      e.preventDefault();
    }
    props.children.props.onKeyDown && props.children.props.onKeyDown(e);
  }, [dispatch, props.children]);
  var onBlurCallback = useCallback(function (e) {
    dispatch({
      type: 'END_BLUR'
    });
    props.children.props.onBlur && props.children.props.onBlur(e);
  }, [dispatch, props.children]);
  var childElement = React__default.Children.only(props.children);
  return React__default.cloneElement(childElement, {
    value: state.endInputValue,
    ref: endInputRef,
    onChange: composeEventHandlers(childElement.props.onChange, onChangeCallback),
    onFocus: composeEventHandlers(childElement.props.onFocus, onFocusCallback),
    onKeyDown: composeEventHandlers(childElement.props.onKeyDown, onKeydownCallback),
    onBlur: composeEventHandlers(childElement.props.onBlur, onBlurCallback)
  });
};

function subDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addDays(dirtyDate, -amount);
}

var Month = function Month(_ref) {
  var locale = _ref.locale,
      displayDate = _ref.displayDate,
      isCompact = _ref.isCompact,
      isPreviousHidden = _ref.isPreviousHidden,
      isNextHidden = _ref.isNextHidden,
      dispatch = _ref.dispatch,
      minValue = _ref.minValue,
      maxValue = _ref.maxValue,
      startValue = _ref.startValue,
      endValue = _ref.endValue,
      hoverDate = _ref.hoverDate;
  var headerLabelFormatter = useCallback(function (date) {
    var formatter = new Intl.DateTimeFormat(locale, {
      month: 'long',
      year: 'numeric'
    });
    return formatter.format(date);
  }, [locale]);
  var dayLabelFormatter = useCallback(function (date) {
    var formatter = new Intl.DateTimeFormat(locale, {
      weekday: 'short'
    });
    return formatter.format(date);
  }, [locale]);
  var dayFormatter = useCallback(function (date) {
    var formatter = new Intl.DateTimeFormat(locale, {
      day: 'numeric'
    });
    return formatter.format(date);
  }, [locale]);
  var weekStartsOn = getStartOfWeek(locale);
  var monthStartDate = startOfMonth(displayDate);
  var monthEndDate = endOfMonth(monthStartDate);
  var startDate = startOfWeek(monthStartDate, {
    weekStartsOn: weekStartsOn
  });
  var endDate = endOfWeek(monthEndDate, {
    weekStartsOn: weekStartsOn
  });
  var dayLabels = eachDayOfInterval({
    start: startDate,
    end: addDays(startDate, 6)
  }).map(function (date) {
    var formattedDayLabel = dayLabelFormatter(date);
    return React__default.createElement(StyledCalendarItem, {
      key: "day-label-".concat(formattedDayLabel),
      isCompact: isCompact
    }, React__default.createElement(StyledDayLabel, {
      isCompact: isCompact
    }, formattedDayLabel));
  });
  var items = eachDayOfInterval({
    start: startDate,
    end: endDate
  }).map(function (date, itemsIndex) {
    var formattedDayLabel = dayFormatter(date);
    var isCurrentDate = isToday(date);
    var isPreviousMonth = !isSameMonth(date, displayDate);
    if (isPreviousMonth) {
      return React__default.createElement(StyledCalendarItem, {
        key: "day-".concat(itemsIndex),
        isCompact: isCompact
      }, React__default.createElement(StyledDay, {
        isCompact: isCompact,
        isPreviousMonth: true,
        isDisabled: true
      }, "\xA0"));
    }
    var isSelected = false;
    if (startValue !== undefined) {
      isSelected = isSameDay(date, startValue);
    }
    if (endValue !== undefined) {
      isSelected = isSelected || isSameDay(date, endValue);
    }
    var isDisabled = false;
    if (minValue !== undefined) {
      isDisabled = isBefore(date, minValue) && !isSameDay(date, minValue);
    }
    if (maxValue !== undefined) {
      isDisabled = isDisabled || isAfter(date, maxValue) && !isSameDay(date, maxValue);
    }
    var isHighlighted = false;
    if (startValue !== undefined && endValue !== undefined) {
      isHighlighted = (isAfter(date, startValue) || isSameDay(date, startValue)) && (isBefore(date, endValue) || isSameDay(date, endValue)) && !isSameDay(startValue, endValue);
    } else if (startValue !== undefined && hoverDate !== undefined) {
      isHighlighted = (isAfter(date, startValue) || isSameDay(date, startValue)) && (isBefore(date, hoverDate) || isSameDay(date, hoverDate));
    }
    var isHighlightStart = isHighlighted && startValue && isSameDay(date, startValue) || false;
    var isHighlightEnd = isHighlighted && endValue && isSameDay(date, endValue) || hoverDate && isSameDay(date, hoverDate) && !isBefore(date, endValue) || false;
    var isInvalidDateRange = endValue && startValue && compareAsc(endValue, startValue) === -1 || false;
    if (minValue) {
      if (startValue) {
        isInvalidDateRange = isInvalidDateRange || compareAsc(startValue, subDays(minValue, 1)) === -1;
      }
      if (endValue) {
        isInvalidDateRange = isInvalidDateRange || compareAsc(endValue, subDays(minValue, 1)) === -1;
      }
    }
    if (maxValue) {
      if (startValue) {
        isInvalidDateRange = isInvalidDateRange || compareAsc(startValue, maxValue) === 1;
      }
      if (endValue) {
        isInvalidDateRange = isInvalidDateRange || compareAsc(endValue, maxValue) === 1;
      }
    }
    return React__default.createElement(StyledCalendarItem, {
      key: "day-".concat(itemsIndex),
      isCompact: isCompact
    }, React__default.createElement(StyledHighlight, {
      isHighlighted: !isInvalidDateRange && isHighlighted && !isDisabled,
      isStart: !isInvalidDateRange && isHighlightStart,
      isEnd: !isInvalidDateRange && isHighlightEnd
    }), React__default.createElement(StyledDay, {
      isToday: isCurrentDate,
      isPreviousMonth: isPreviousMonth,
      isSelected: !isInvalidDateRange && isSelected,
      isDisabled: isDisabled,
      isCompact: isCompact,
      onClick: function onClick() {
        if (!isDisabled) {
          dispatch({
            type: 'CLICK_DATE',
            value: date
          });
        }
      },
      onMouseEnter: function onMouseEnter() {
        if (!isSelected) {
          dispatch({
            type: 'HOVER_DATE',
            value: date
          });
        }
      }
    }, formattedDayLabel));
  });
  return React__default.createElement(StyledDatepicker, {
    isCompact: isCompact,
    onMouseDown: function onMouseDown(e) {
      e.preventDefault();
    }
  }, React__default.createElement(StyledHeader, {
    isCompact: isCompact
  }, React__default.createElement(StyledHeaderPaddle, {
    isCompact: isCompact,
    onClick: function onClick() {
      dispatch({
        type: 'PREVIEW_PREVIOUS_MONTH'
      });
    },
    isHidden: isPreviousHidden
  }, React__default.createElement(SvgChevronLeftStroke, null)), React__default.createElement(StyledHeaderLabel, {
    isCompact: isCompact
  }, headerLabelFormatter(displayDate)), React__default.createElement(StyledHeaderPaddle, {
    isCompact: isCompact,
    isHidden: isNextHidden,
    onClick: function onClick() {
      dispatch({
        type: 'PREVIEW_NEXT_MONTH'
      });
    }
  }, React__default.createElement(SvgChevronRightStroke, null))), React__default.createElement(StyledCalendar, {
    isCompact: isCompact,
    onMouseLeave: function onMouseLeave() {
      dispatch({
        type: 'HOVER_DATE',
        value: undefined
      });
    }
  }, dayLabels, items));
};

var Calendar = function Calendar(props) {
  var _useDatepickerRangeCo = useDatepickerContext(),
      state = _useDatepickerRangeCo.state,
      dispatch = _useDatepickerRangeCo.dispatch,
      locale = _useDatepickerRangeCo.locale,
      isCompact = _useDatepickerRangeCo.isCompact,
      minValue = _useDatepickerRangeCo.minValue,
      maxValue = _useDatepickerRangeCo.maxValue,
      startValue = _useDatepickerRangeCo.startValue,
      endValue = _useDatepickerRangeCo.endValue,
      onChange = _useDatepickerRangeCo.onChange;
  return React__default.createElement(StyledRangeCalendar, _extends$2({
    "data-garden-id": "datepickers.range",
    "data-garden-version": '8.47.1'
  }, props), React__default.createElement(Month, {
    locale: locale,
    displayDate: state.previewDate,
    isCompact: isCompact,
    isNextHidden: true,
    dispatch: dispatch,
    minValue: minValue,
    maxValue: maxValue,
    startValue: startValue,
    endValue: endValue,
    onChange: onChange,
    hoverDate: state.hoverDate
  }), React__default.createElement(Month, {
    locale: locale,
    displayDate: addMonths(state.previewDate, 1),
    isCompact: isCompact,
    isPreviousHidden: true,
    dispatch: dispatch,
    minValue: minValue,
    maxValue: maxValue,
    startValue: startValue,
    endValue: endValue,
    onChange: onChange,
    hoverDate: state.hoverDate
  }));
};

var DatepickerRange = function DatepickerRange(props) {
  var startValue = props.startValue,
      locale = props.locale,
      formatDate = props.formatDate,
      endValue = props.endValue,
      onChange = props.onChange,
      customParseDate = props.customParseDate,
      isCompact = props.isCompact,
      minValue = props.minValue,
      maxValue = props.maxValue,
      children = props.children;
  var reducer = useCallback(datepickerRangeReducer({
    startValue: startValue,
    locale: locale,
    formatDate: formatDate,
    endValue: endValue,
    onChange: onChange,
    customParseDate: customParseDate
  }), [startValue, endValue, locale, formatDate, onChange, customParseDate]);
  var _useReducer = useReducer(reducer, retrieveInitialState(props)),
      _useReducer2 = _slicedToArray(_useReducer, 2),
      state = _useReducer2[0],
      dispatch = _useReducer2[1];
  var previousStartValue = useRef(startValue);
  var previousEndValue = useRef(endValue);
  var startInputRef = useRef();
  var endInputRef = useRef();
  useEffect(function () {
    dispatch({
      type: 'CONTROLLED_START_VALUE_CHANGE',
      value: startValue
    });
    if (endInputRef.current && previousStartValue.current !== startValue && startValue !== undefined) {
      endInputRef.current.focus();
    }
    previousStartValue.current = startValue;
  }, [props, startValue]);
  useEffect(function () {
    dispatch({
      type: 'CONTROLLED_END_VALUE_CHANGE',
      value: endValue
    });
    if (startInputRef.current && previousEndValue.current !== endValue && endValue !== undefined) {
      startInputRef.current.focus();
    }
    previousEndValue.current = endValue;
  }, [props, endValue]);
  var value = useMemo(function () {
    return {
      state: state,
      dispatch: dispatch,
      isCompact: isCompact,
      locale: locale,
      minValue: minValue,
      maxValue: maxValue,
      startValue: startValue,
      endValue: endValue,
      onChange: onChange,
      startInputRef: startInputRef,
      endInputRef: endInputRef
    };
  }, [state, dispatch, isCompact, locale, minValue, maxValue, startValue, endValue, onChange, startInputRef, endInputRef]);
  return React__default.createElement(DatepickerRangeContext.Provider, {
    value: value
  }, children);
};
DatepickerRange.Start = Start;
DatepickerRange.End = End;
DatepickerRange.Calendar = Calendar;
DatepickerRange.propTypes = {
  locale: PropTypes.string,
  startValue: PropTypes.instanceOf(Date),
  endValue: PropTypes.instanceOf(Date),
  minValue: PropTypes.instanceOf(Date),
  maxValue: PropTypes.instanceOf(Date),
  onChange: PropTypes.func,
  formatDate: PropTypes.func,
  customParseDate: PropTypes.func,
  isCompact: PropTypes.bool
};
DatepickerRange.defaultProps = {
  locale: 'en-US',
  isCompact: false
};

export { Datepicker, DatepickerRange };
