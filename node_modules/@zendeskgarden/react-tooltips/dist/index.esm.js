/**
 * Copyright Zendesk, Inc.
 *
 * Use of this source code is governed under the Apache License, Version 2.0
 * found at http://www.apache.org/licenses/LICENSE-2.0.
 */

import React, { useContext, useRef, useEffect, cloneElement } from 'react';
import { createPortal } from 'react-dom';
import PropTypes from 'prop-types';
import styled, { css, ThemeContext } from 'styled-components';
import mergeRefs from 'react-merge-refs';
import { useTooltip } from '@zendeskgarden/container-tooltip';
import { getControlledValue, composeEventHandlers } from '@zendeskgarden/container-utilities';
import { Manager, Reference, Popper } from 'react-popper';
import { retrieveComponentStyles, DEFAULT_THEME, arrowStyles, getLineHeight, getColor } from '@zendeskgarden/react-theming';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function getPopperPlacement(gardenPlacement) {
  var gardenToPopperMapping = {
    auto: 'auto',
    top: 'top',
    'top-start': 'top-start',
    'top-end': 'top-end',
    bottom: 'bottom',
    'bottom-start': 'bottom-start',
    'bottom-end': 'bottom-end',
    end: 'right',
    'end-top': 'right-start',
    'end-bottom': 'right-end',
    start: 'left',
    'start-top': 'left-start',
    'start-bottom': 'left-end'
  };
  return gardenToPopperMapping[gardenPlacement];
}
function getRtlPopperPlacement(gardenPlacement) {
  var rtlPlacementMappings = {
    left: 'right',
    'left-start': 'right-start',
    'left-end': 'right-end',
    'top-start': 'top-end',
    'top-end': 'top-start',
    right: 'left',
    'right-start': 'left-start',
    'right-end': 'left-end',
    'bottom-start': 'bottom-end',
    'bottom-end': 'bottom-start'
  };
  var popperPlacement = getPopperPlacement(gardenPlacement);
  return rtlPlacementMappings[popperPlacement] || popperPlacement;
}
function getArrowPosition(popperPlacement) {
  var arrowPositionMappings = {
    top: 'bottom',
    'top-start': 'bottom-left',
    'top-end': 'bottom-right',
    right: 'left',
    'right-start': 'left-top',
    'right-end': 'left-bottom',
    bottom: 'top',
    'bottom-start': 'top-left',
    'bottom-end': 'top-right',
    left: 'right',
    'left-start': 'right-top',
    'left-end': 'right-bottom'
  };
  return arrowPositionMappings[popperPlacement] || 'top';
}

var COMPONENT_ID$2 = 'tooltip.paragraph';
var StyledParagraph = styled.p.attrs({
  'data-garden-id': COMPONENT_ID$2,
  'data-garden-version': '8.47.1'
}).withConfig({
  displayName: "StyledParagraph",
  componentId: "sc-wuqkfc-0"
})(["margin:0;", ";"], function (props) {
  return retrieveComponentStyles(COMPONENT_ID$2, props);
});
StyledParagraph.defaultProps = {
  theme: DEFAULT_THEME
};

var COMPONENT_ID$1 = 'tooltip.title';
var StyledTitle = styled.strong.attrs({
  'data-garden-id': COMPONENT_ID$1,
  'data-garden-version': '8.47.1'
}).withConfig({
  displayName: "StyledTitle",
  componentId: "sc-vnjcvz-0"
})(["display:none;margin:0;font-weight:", ";", ";"], function (props) {
  return props.theme.fontWeights.semibold;
}, function (props) {
  return retrieveComponentStyles(COMPONENT_ID$1, props);
});
StyledTitle.defaultProps = {
  theme: DEFAULT_THEME
};

var COMPONENT_ID = 'tooltip.tooltip';
var sizeStyles = function sizeStyles(_ref) {
  var theme = _ref.theme,
      size = _ref.size,
      type = _ref.type,
      placement = _ref.placement,
      hasArrow = _ref.hasArrow;
  var margin = "".concat(theme.space.base * 1.5, "px");
  var borderRadius = theme.borderRadii.sm;
  var padding = '0 1em';
  var maxWidth;
  var overflowWrap;
  var whiteSpace = 'nowrap';
  var lineHeight = getLineHeight(theme.space.base * 5, theme.fontSizes.sm);
  var fontSize = theme.fontSizes.sm;
  var titleDisplay;
  var paragraphMarginTop;
  var wordWrap;
  if (size !== 'small') {
    borderRadius = theme.borderRadii.md;
    overflowWrap = 'break-word';
    whiteSpace = 'normal';
    wordWrap = 'break-word';
  }
  if (size === 'extra-large') {
    padding = "".concat(theme.space.base * 10, "px");
    maxWidth = "460px";
    lineHeight = getLineHeight(theme.space.base * 5, theme.fontSizes.md);
    paragraphMarginTop = "".concat(theme.space.base * 2.5, "px");
  } else if (size === 'large') {
    padding = "".concat(theme.space.base * 5, "px");
    maxWidth = "270px";
    lineHeight = getLineHeight(theme.space.base * 5, theme.fontSizes.md);
    paragraphMarginTop = "".concat(theme.space.base * 2, "px");
  } else if (size === 'medium') {
    padding = '1em';
    maxWidth = "140px";
    lineHeight = getLineHeight(theme.space.base * 4, theme.fontSizes.sm);
  }
  if (size === 'extra-large' || size === 'large') {
    fontSize = theme.fontSizes.md;
    titleDisplay = 'block';
  }
  var arrowSize;
  var arrowInset;
  if (hasArrow) {
    if (size === 'small' || size === 'medium') {
      arrowSize = margin;
      arrowInset = type === 'dark' ? '1px' : '0';
    } else {
      arrowInset = type === 'dark' ? '2px' : '1px';
      if (size === 'large') {
        margin = "".concat(theme.space.base * 2, "px");
        arrowSize = margin;
      } else if (size === 'extra-large') {
        margin = "".concat(theme.space.base * 3, "px");
        arrowSize = "".concat(theme.space.base * 2.5, "px");
      }
    }
  }
  return css(["margin:", ";border-radius:", ";padding:", ";max-width:", ";line-height:", ";word-wrap:", ";white-space:", ";font-size:", ";overflow-wrap:", ";", ";", "{margin-top:", ";}", "{display:", ";}"], margin, borderRadius, padding, maxWidth, lineHeight, wordWrap, whiteSpace, fontSize, overflowWrap, hasArrow && arrowStyles(getArrowPosition(placement), {
    size: arrowSize,
    inset: arrowInset
  }), StyledParagraph, paragraphMarginTop, StyledTitle, titleDisplay);
};
var colorStyles = function colorStyles(_ref2) {
  var theme = _ref2.theme,
      type = _ref2.type;
  var border;
  var boxShadow = theme.shadows.lg("".concat(theme.space.base, "px"), "".concat(theme.space.base * 2, "px"), getColor('chromeHue', 600, theme, 0.15));
  var backgroundColor = getColor('chromeHue', 700, theme);
  var color = theme.colors.background;
  var titleColor;
  if (type === 'light') {
    boxShadow = theme.shadows.lg("".concat(theme.space.base * 3, "px"), "".concat(theme.space.base * 5, "px"), getColor('chromeHue', 600, theme, 0.15));
    border = "".concat(theme.borders.sm, " ").concat(getColor('neutralHue', 300, theme));
    backgroundColor = theme.colors.background;
    color = getColor('neutralHue', 700, theme);
    titleColor = theme.colors.foreground;
  }
  return css(["border:", ";box-shadow:", ";background-color:", ";color:", ";", "{color:", ";}"], border, boxShadow, backgroundColor, color, StyledTitle, titleColor);
};
var StyledTooltip = styled.div.attrs({
  'data-garden-id': COMPONENT_ID,
  'data-garden-version': '8.47.1'
}).withConfig({
  displayName: "StyledTooltip",
  componentId: "sc-gzzjq4-0"
})(["display:inline-block;box-sizing:border-box;direction:", ";text-align:", ";font-weight:", ";", ";&[aria-hidden='true']{display:none;}", ";", ";"], function (props) {
  return props.theme.rtl && 'rtl';
}, function (props) {
  return props.theme.rtl ? 'right' : 'left';
}, function (props) {
  return props.theme.fontWeights.regular;
}, function (props) {
  return sizeStyles(props);
}, colorStyles, function (props) {
  return retrieveComponentStyles(COMPONENT_ID, props);
});
StyledTooltip.defaultProps = {
  theme: DEFAULT_THEME
};

var StyledTooltipWrapper = styled.div.withConfig({
  displayName: "StyledTooltipWrapper",
  componentId: "sc-1b7q9q6-0"
})(["transition:opacity 10ms;opacity:1;z-index:", ";&[aria-hidden='true']{visibility:hidden;opacity:0;}"], function (props) {
  return props.zIndex;
});
StyledTooltipWrapper.defaultProps = {
  theme: DEFAULT_THEME
};

var _excluded = ["id", "delayMS", "isInitialVisible", "content", "refKey", "placement", "eventsEnabled", "popperModifiers", "children", "hasArrow", "size", "type", "appendToNode", "zIndex", "isVisible"],
    _excluded2 = ["onFocus", "onBlur"];
var Tooltip = function Tooltip(_ref) {
  var id = _ref.id,
      delayMS = _ref.delayMS,
      isInitialVisible = _ref.isInitialVisible,
      content = _ref.content,
      refKey = _ref.refKey,
      placement = _ref.placement,
      eventsEnabled = _ref.eventsEnabled,
      popperModifiers = _ref.popperModifiers,
      children = _ref.children,
      hasArrow = _ref.hasArrow,
      size = _ref.size,
      type = _ref.type,
      appendToNode = _ref.appendToNode,
      zIndex = _ref.zIndex,
      externalIsVisible = _ref.isVisible,
      otherProps = _objectWithoutProperties(_ref, _excluded);
  var theme = useContext(ThemeContext);
  var scheduleUpdateRef = useRef();
  var _useTooltip = useTooltip({
    id: id,
    delayMilliseconds: delayMS,
    isVisible: isInitialVisible
  }),
      isVisible = _useTooltip.isVisible,
      getTooltipProps = _useTooltip.getTooltipProps,
      getTriggerProps = _useTooltip.getTriggerProps,
      openTooltip = _useTooltip.openTooltip,
      closeTooltip = _useTooltip.closeTooltip;
  var controlledIsVisible = getControlledValue(externalIsVisible, isVisible);
  useEffect(function () {
    if (controlledIsVisible && scheduleUpdateRef.current) {
      scheduleUpdateRef.current();
    }
  }, [controlledIsVisible, content]);
  var popperPlacement = theme.rtl ? getRtlPopperPlacement(placement) : getPopperPlacement(placement);
  var singleChild = React.Children.only(children);
  var modifiers = _objectSpread2({
    preventOverflow: {
      boundariesElement: 'window'
    }
  }, popperModifiers);
  return React.createElement(Manager, null, React.createElement(Reference, null, function (_ref2) {
    var ref = _ref2.ref;
    return cloneElement(singleChild, getTriggerProps(_objectSpread2(_objectSpread2({}, singleChild.props), {}, _defineProperty({}, refKey, mergeRefs([ref, singleChild.ref ? singleChild.ref : null])))));
  }), React.createElement(Popper, {
    placement: popperPlacement,
    eventsEnabled: controlledIsVisible && eventsEnabled,
    modifiers: modifiers
  }, function (_ref3) {
    var ref = _ref3.ref,
        style = _ref3.style,
        scheduleUpdate = _ref3.scheduleUpdate,
        currentPlacement = _ref3.placement;
    scheduleUpdateRef.current = scheduleUpdate;
    var onFocus = otherProps.onFocus,
        onBlur = otherProps.onBlur,
        otherTooltipProps = _objectWithoutProperties(otherProps, _excluded2);
    var computedSize = size;
    if (computedSize === undefined) {
      if (type === 'dark') {
        computedSize = 'small';
      } else {
        computedSize = 'large';
      }
    }
    var tooltipProps = _objectSpread2({
      hasArrow: hasArrow,
      placement: currentPlacement,
      size: computedSize,
      onFocus: composeEventHandlers(onFocus, function () {
        openTooltip();
      }),
      onBlur: composeEventHandlers(onBlur, function () {
        closeTooltip(0);
      }),
      'aria-hidden': !controlledIsVisible,
      type: type
    }, otherTooltipProps);
    var tooltip = React.createElement(StyledTooltipWrapper, {
      ref: controlledIsVisible ? ref : null,
      style: style,
      zIndex: zIndex,
      "aria-hidden": !controlledIsVisible
    }, React.createElement(StyledTooltip, getTooltipProps(tooltipProps), content));
    if (appendToNode) {
      return createPortal(tooltip, appendToNode);
    }
    return tooltip;
  }));
};
Tooltip.displayName = 'Tooltip';
Tooltip.propTypes = {
  appendToNode: PropTypes.any,
  hasArrow: PropTypes.bool,
  delayMS: PropTypes.number,
  eventsEnabled: PropTypes.bool,
  id: PropTypes.string,
  content: PropTypes.node.isRequired,
  placement: PropTypes.oneOf(['auto', 'top', 'top-start', 'top-end', 'end', 'end-top', 'end-bottom', 'bottom', 'bottom-start', 'bottom-end', 'start', 'start-top', 'start-bottom']),
  popperModifiers: PropTypes.any,
  size: PropTypes.oneOf(['small', 'medium', 'large', 'extra-large']),
  type: PropTypes.oneOf(['light', 'dark']),
  zIndex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  isInitialVisible: PropTypes.bool,
  refKey: PropTypes.string
};
Tooltip.defaultProps = {
  hasArrow: true,
  eventsEnabled: true,
  type: 'dark',
  placement: 'top',
  delayMS: 500,
  refKey: 'ref'
};

var Paragraph = React.forwardRef(function (props, ref) {
  return React.createElement(StyledParagraph, _extends({
    ref: ref
  }, props));
});
Paragraph.displayName = 'Paragraph';

var Title = React.forwardRef(function (props, ref) {
  return React.createElement(StyledTitle, _extends({
    ref: ref
  }, props));
});
Title.displayName = 'Title';

export { Paragraph, Title, Tooltip };
